import { Signer, BigNumber, ethers } from 'ethers';
import { L1Bridge } from './l1Bridge';
import { L2Bridge } from './l2Bridge';
import { TransactionOverrides } from './bridge_helpers';
export declare class Bridge extends L2Bridge {
    l1Bridge: L1Bridge;
    walletAddressCache?: string;
    constructor(erc20BridgeAddress: string, arbERC20BridgeAddress: string, ethSigner: Signer, arbSigner: Signer);
    updateAllBalances(): void;
    updateAllTokens(): Promise<{
        l1Tokens: import("./l1Bridge").Tokens;
        l2Tokens: import("./l2Bridge").Tokens;
    }>;
    updateTokenData(erc20l1Address: string): Promise<{
        l1Data: import("./l1Bridge").L1TokenData;
        l2Data: import("./l2Bridge").L2TokenData | undefined;
    }>;
    get l1Tokens(): import("./l1Bridge").Tokens;
    get l1EthBalance(): BigNumber;
    get ethERC20Bridge(): import("./abi").EthERC20Bridge;
    approveToken(erc20L1Address: string, overrides?: TransactionOverrides): Promise<ethers.ContractTransaction>;
    depositETH(value: BigNumber, destinationAddress?: string, maxGas?: BigNumber, overrides?: TransactionOverrides): Promise<ethers.ContractTransaction>;
    deposit(erc20L1Address: string, amount: BigNumber, maxGas: BigNumber, gasPriceBid: BigNumber, destinationAddress?: string, overrides?: TransactionOverrides): Promise<ethers.ContractTransaction>;
    getAndUpdateL1TokenData(erc20l1Address: string): Promise<import("./l1Bridge").L1TokenData>;
    getAndUpdateL1EthBalance(): Promise<BigNumber>;
    getL2Transaction(l2TransactionHash: string): Promise<ethers.providers.TransactionReceipt>;
    getL1Transaction(l1TransactionHash: string): Promise<ethers.providers.TransactionReceipt>;
    calculateL2TransactionHash(inboxSequenceNumber: BigNumber, l2ChainId?: BigNumber): Promise<string>;
    calculateL2RetryableTransactionHash(inboxSequenceNumber: BigNumber, l2ChainId?: BigNumber): Promise<string>;
    getInboxSeqNumFromContractTransaction(l2Transaction: ethers.providers.TransactionReceipt): Promise<Array<BigNumber> | undefined>;
    getBuddyDeployInL2Transaction(l2Transaction: ethers.providers.TransactionReceipt): Promise<import("./bridge_helpers").BuddyDeployEventResult[]>;
    getWithdrawalsInL2Transaction(l2Transaction: ethers.providers.TransactionReceipt): Promise<import("./bridge_helpers").L2ToL1EventResult[]>;
    getDepositTokenEventData(l1Transaction: ethers.providers.TransactionReceipt): Promise<import("./bridge_helpers").DepositTokenEventResult[]>;
    triggerL2ToL1Transaction(batchNumber: BigNumber, indexInBatch: BigNumber, singleAttempt?: boolean): Promise<ethers.ContractReceipt>;
    tryOutboxExecute(activeOutboxAddress: string, batchNumber: BigNumber, proof: Array<string>, path: BigNumber, l2Sender: string, l1Dest: string, l2Block: BigNumber, l1Block: BigNumber, timestamp: BigNumber, amount: BigNumber, calldataForL1: string): Promise<ethers.ContractReceipt>;
    tryGetProofOnce(batchNumber: BigNumber, indexInBatch: BigNumber): Promise<{
        proof: string[];
        path: BigNumber;
        l2Sender: string;
        l1Dest: string;
        l2Block: BigNumber;
        l1Block: BigNumber;
        timestamp: BigNumber;
        amount: BigNumber;
        calldataForL1: string;
    } | null>;
    tryGetProof(batchNumber: BigNumber, indexInBatch: BigNumber, retryDelay?: number): Promise<{
        proof: string[];
        path: BigNumber;
        l2Sender: string;
        l1Dest: string;
        l2Block: BigNumber;
        l1Block: BigNumber;
        timestamp: BigNumber;
        amount: BigNumber;
        calldataForL1: string;
    }>;
    waitUntilOutboxEntryCreated(batchNumber: BigNumber, activeOutboxAddress: string): Promise<string>;
    waitForRetriableReceipt(seqNum: BigNumber): Promise<ethers.providers.TransactionReceipt>;
    getTokenWithdrawEventData(destinationAddress: string): Promise<import("./bridge_helpers").WithdrawTokenEventResult[]>;
    getL2ToL1EventData(destinationAddress: string): Promise<import("./bridge_helpers").L2ToL1EventResult[]>;
}
