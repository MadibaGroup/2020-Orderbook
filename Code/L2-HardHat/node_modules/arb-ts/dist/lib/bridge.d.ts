import { Signer, BigNumber, ethers, ContractReceipt } from 'ethers';
import { L1Bridge } from './l1Bridge';
import { L2Bridge } from './l2Bridge';
import { PayableOverrides } from '@ethersproject/contracts';
interface RetryableGasArgs {
    maxSubmissionPrice?: BigNumber;
    maxGas?: BigNumber;
    gasPriceBid?: BigNumber;
    maxSubmissionPricePercentIncrease?: BigNumber;
}
/**
 * Main class for accessing token bridge methods; inherits methods from {@link L1Bridge} and {@link L2Bridge}
 */
export declare class Bridge {
    l1Bridge: L1Bridge;
    l2Bridge: L2Bridge;
    walletAddressCache?: string;
    outboxAddressCache?: string;
    isCustomNetwork: boolean;
    private constructor();
    updateAllBalances(): void;
    static init(ethSigner: Signer, arbSigner: Signer, l1GatewayRouterAddress?: string, l2GatewayRouterAddress?: string): Promise<Bridge>;
    /**
     * Update state of all tracked tokens (balance, allowance), etc. and returns state
     */
    updateAllTokens(): Promise<{
        l1Tokens: import("./l1Bridge").Tokens;
        l2Tokens: import("./l2Bridge").Tokens;
    }>;
    /**
     * Update target token (balance, allowance), etc. and state
     */
    updateTokenData(erc20l1Address: string): Promise<{
        l1Data: import("./l1Bridge").L1TokenData;
        l2Data: import("./l2Bridge").L2TokenData | undefined;
    }>;
    get l1Tokens(): import("./l1Bridge").Tokens;
    get l1GatewayRouter(): import("./abi").L1GatewayRouter;
    defaultL1Gateway(): Promise<import("./abi").L1ERC20Gateway>;
    get l1Signer(): Signer;
    get l1Provider(): ethers.providers.Provider;
    get l2Provider(): ethers.providers.Provider;
    get l2Signer(): Signer;
    /**
     * Set allowance for L1 router contract
     */
    approveToken(erc20L1Address: string, amount?: BigNumber, overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    /**
     * Deposit ether from L1 to L2.
     */
    depositETH(value: BigNumber, _maxSubmissionPricePercentIncrease?: BigNumber, overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    private looksLikeWethGateway;
    /**
     * Token deposit; if no value given, calculates and includes minimum necessary value to fund L2 side of execution
     */
    deposit(erc20L1Address: string, amount: BigNumber, retryableGasArgs?: RetryableGasArgs, destinationAddress?: string, overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    getAndUpdateL1TokenData(erc20l1Address: string): Promise<import("./l1Bridge").L1TokenData>;
    getAndUpdateL2TokenData(erc20l1Address: string): Promise<import("./l2Bridge").L2TokenData | undefined>;
    getL1EthBalance(): Promise<BigNumber>;
    getL2EthBalance(): Promise<BigNumber>;
    getL2Transaction(l2TransactionHash: string): Promise<ethers.providers.TransactionReceipt>;
    getL1Transaction(l1TransactionHash: string): Promise<ethers.providers.TransactionReceipt>;
    /**
     * get hash of regular L2 txn from corresponding inbox sequence number
     */
    calculateL2TransactionHash(inboxSequenceNumber: BigNumber, l2ChainId?: BigNumber): Promise<string>;
    /**
     * Hash of L2 side of retryable txn; txn gets generated automatically and is formatted as tho user submitted
     */
    calculateL2RetryableTransactionHash(inboxSequenceNumber: BigNumber, l2ChainId?: BigNumber): Promise<string>;
    /**
     * Hash of L2 ArbOs generated "auto-redeem" transaction; if it succeeded, a transaction queryable by {@link calculateL2RetryableTransactionHash} will then be created
     */
    calculateRetryableAutoRedeemTxnHash(inboxSequenceNumber: BigNumber, l2ChainId?: BigNumber): Promise<string>;
    getInboxSeqNumFromContractTransaction(l1Transaction: ethers.providers.TransactionReceipt): Promise<BigNumber[] | undefined>;
    /**
     * Convenience method to directly retrieve retryable hash from an l1 transaction
     */
    getL2TxHashByRetryableTicket(l1Transaction: string | ContractReceipt): Promise<string>;
    redeemRetryableTicket(l1Transaction: string | ContractReceipt, waitTimeForL2Receipt?: number, // 15 minutes
    overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    cancelRetryableTicket(l1Transaction: string | ContractReceipt, waitTimeForL2Receipt?: number, // 15 minutes
    overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    getBuddyDeployInL2Transaction(l2Transaction: ethers.providers.TransactionReceipt): Promise<import("./bridge_helpers").BuddyDeployEventResult[]>;
    getWithdrawalsInL2Transaction(l2Transaction: ethers.providers.TransactionReceipt): import("./bridge_helpers").L2ToL1EventResult[];
    getDepositTokenEventData(l1Transaction: ethers.providers.TransactionReceipt): Promise<import("./bridge_helpers").DepositInitiated[]>;
    /**
     * Attempt to execute an outbox message; must be confirmed to succeed (i.e., confirmation delay must have passed)
     */
    triggerL2ToL1Transaction(batchNumber: BigNumber, indexInBatch: BigNumber, singleAttempt?: boolean): Promise<ethers.ContractTransaction>;
    tryOutboxExecute(outboxAddress: string, batchNumber: BigNumber, proof: Array<string>, path: BigNumber, l2Sender: string, l1Dest: string, l2Block: BigNumber, l1Block: BigNumber, timestamp: BigNumber, amount: BigNumber, calldataForL1: string): Promise<ethers.ContractTransaction>;
    tryGetProofOnce(batchNumber: BigNumber, indexInBatch: BigNumber): Promise<{
        proof: string[];
        path: BigNumber;
        l2Sender: string;
        l1Dest: string;
        l2Block: BigNumber;
        l1Block: BigNumber;
        timestamp: BigNumber;
        amount: BigNumber;
        calldataForL1: string;
    } | null>;
    tryGetProof(batchNumber: BigNumber, indexInBatch: BigNumber, retryDelay?: number): Promise<{
        proof: string[];
        path: BigNumber;
        l2Sender: string;
        l1Dest: string;
        l2Block: BigNumber;
        l1Block: BigNumber;
        timestamp: BigNumber;
        amount: BigNumber;
        calldataForL1: string;
    }>;
    waitUntilOutboxEntryCreated(batchNumber: BigNumber, outboxAddress: string): Promise<void>;
    /**
     * Return receipt of retryable transaction after execution
     */
    waitForRetryableReceipt(seqNum: BigNumber): Promise<ethers.providers.TransactionReceipt>;
    /**
     * All withdrawals from given token
     */
    getTokenWithdrawEventData(l1TokenAddress: string, fromAddress?: string, filter?: ethers.providers.Filter): Promise<import("./bridge_helpers").WithdrawalInitiated[]>;
    /**
     * All withdrawals from given gateway
     */
    getGatewayWithdrawEventData(gatewayAddress: string, fromAddress?: string, filter?: ethers.providers.Filter): Promise<import("./bridge_helpers").WithdrawalInitiated[]>;
    getL2ToL1EventData(fromAddress: string, filter?: ethers.providers.Filter): Promise<import("./bridge_helpers").L2ToL1EventResult[]>;
    getOutboxAddressByBatchNum(batchNum: BigNumber): Promise<string>;
    /**
     * Returns {@link OutgoingMessageState} for given outgoing message
     */
    getOutGoingMessageState(batchNumber: BigNumber, indexInBatch: BigNumber): Promise<import("./bridge_helpers").OutgoingMessageState>;
    getERC20L2Address(erc20L1Address: string): Promise<string>;
    withdrawETH(value: BigNumber, destinationAddress?: string, overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    withdrawERC20(erc20l1Address: string, amount: BigNumber, destinationAddress?: string, overrides?: PayableOverrides): Promise<ethers.ContractTransaction>;
    isWhiteListed(address: string, whiteListAddress: string): Promise<boolean>;
    setGateways(tokenAddresses: string[], gatewayAddresses: string[]): Promise<ethers.ContractTransaction>;
    getL1GatewaySetEventData(_l1GatewayRouterAddress?: string): Promise<import("./bridge_helpers").GatewaySet[]>;
    getL2GatewaySetEventData(_l2GatewayRouterAddress?: string): Promise<import("./bridge_helpers").GatewaySet[]>;
}
export {};
