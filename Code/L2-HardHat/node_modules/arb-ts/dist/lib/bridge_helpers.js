"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeHelper = exports.OutgoingMessageState = exports.addressToSymbol = void 0;
const ethers_1 = require("ethers");
const L1ERC20Gateway__factory_1 = require("./abi/factories/L1ERC20Gateway__factory");
const L1GatewayRouter__factory_1 = require("./abi/factories/L1GatewayRouter__factory");
const Outbox__factory_1 = require("./abi/factories/Outbox__factory");
const IOutbox__factory_1 = require("./abi/factories/IOutbox__factory");
const Inbox__factory_1 = require("./abi/factories/Inbox__factory");
const ArbSys__factory_1 = require("./abi/factories/ArbSys__factory");
const Rollup__factory_1 = require("./abi/factories/Rollup__factory");
const L2ArbitrumGateway__factory_1 = require("./abi/factories/L2ArbitrumGateway__factory");
const ethers_2 = require("ethers");
const ethers_3 = require("ethers");
const precompile_addresses_1 = require("./precompile_addresses");
const Whitelist__factory_1 = require("./abi/factories/Whitelist__factory");
const addressToSymbol = (erc20L1Address) => {
    return erc20L1Address.substr(erc20L1Address.length - 3).toUpperCase() + '?';
};
exports.addressToSymbol = addressToSymbol;
var OutgoingMessageState;
(function (OutgoingMessageState) {
    /**
     * No corresponding {@link L2ToL1EventResult} emitted
     */
    OutgoingMessageState[OutgoingMessageState["NOT_FOUND"] = 0] = "NOT_FOUND";
    /**
     * ArbSys.sendTxToL1 called, but assertion not yet confirmed
     */
    OutgoingMessageState[OutgoingMessageState["UNCONFIRMED"] = 1] = "UNCONFIRMED";
    /**
     * Assertion for outgoing message confirmed, but message not yet executed
     */
    OutgoingMessageState[OutgoingMessageState["CONFIRMED"] = 2] = "CONFIRMED";
    /**
     * Outgoing message executed (terminal state)
     */
    OutgoingMessageState[OutgoingMessageState["EXECUTED"] = 3] = "EXECUTED";
})(OutgoingMessageState = exports.OutgoingMessageState || (exports.OutgoingMessageState = {}));
/**
 * Stateless helper methods; most wrapped / accessible (and documented) via {@link Bridge}
 */
class BridgeHelper {
    /**
     * All withdrawals from given token
     */
    static async getTokenWithdrawEventData(l2Provider, gatewayAddress, l1TokenAddress, fromAddress, filter) {
        const gatewayContract = L2ArbitrumGateway__factory_1.L2ArbitrumGateway__factory.connect(gatewayAddress, l2Provider);
        const topics = [
            null,
            fromAddress ? ethers_2.utils.hexZeroPad(fromAddress, 32) : null,
        ];
        const logs = await BridgeHelper.getEventLogs('WithdrawalInitiated', gatewayContract, 
        // @ts-ignore
        topics, filter);
        return logs
            .map(log => {
            const data = Object.assign(Object.assign({}, gatewayContract.interface.parseLog(log).args), { txHash: log.transactionHash });
            return data;
        })
            .filter((log) => log.l1Token.toLocaleLowerCase() === l1TokenAddress.toLocaleLowerCase());
    }
    static async getGatewayWithdrawEventData(l2Provider, gatewayAddress, fromAddress, filter) {
        const gatewayContract = L2ArbitrumGateway__factory_1.L2ArbitrumGateway__factory.connect(gatewayAddress, l2Provider);
        const topics = [
            null,
            fromAddress ? ethers_2.utils.hexZeroPad(fromAddress, 32) : null,
        ];
        const logs = await BridgeHelper.getEventLogs('WithdrawalInitiated', gatewayContract, 
        // @ts-ignore
        topics, filter);
        return logs.map(log => {
            const data = Object.assign(Object.assign({}, gatewayContract.interface.parseLog(log).args), { txHash: log.transactionHash });
            return data;
        });
    }
    static isWhiteListed(address, whiteListAddress, l1Provider) {
        const whiteList = Whitelist__factory_1.Whitelist__factory.connect(whiteListAddress, l1Provider);
        return whiteList.isAllowed(address);
    }
    static percentIncrease(num, increase) {
        return num.add(num.mul(increase).div(100));
    }
}
exports.BridgeHelper = BridgeHelper;
BridgeHelper.calculateL2TransactionHash = async (inboxSequenceNumber, chainIdOrL2Provider) => {
    const l2ChainId = ethers_3.BigNumber.isBigNumber(chainIdOrL2Provider)
        ? chainIdOrL2Provider
        : ethers_3.BigNumber.from((await chainIdOrL2Provider.getNetwork()).chainId);
    return ethers_2.utils.keccak256(ethers_2.utils.concat([
        ethers_2.utils.zeroPad(l2ChainId.toHexString(), 32),
        ethers_2.utils.zeroPad(BridgeHelper.bitFlipSeqNum(inboxSequenceNumber).toHexString(), 32),
    ]));
};
BridgeHelper.bitFlipSeqNum = (seqNum) => {
    return seqNum.or(ethers_3.BigNumber.from(1).shl(255));
};
BridgeHelper._calculateRetryableHashInternal = async (inboxSequenceNumber, chainIdOrL2Provider, txnType) => {
    const requestID = await BridgeHelper.calculateL2TransactionHash(inboxSequenceNumber, chainIdOrL2Provider);
    return ethers_2.utils.keccak256(ethers_2.utils.concat([
        ethers_2.utils.zeroPad(requestID, 32),
        ethers_2.utils.zeroPad(ethers_3.BigNumber.from(txnType).toHexString(), 32),
    ]));
};
BridgeHelper.calculateL2RetryableTransactionHash = async (inboxSequenceNumber, chainIdOrL2Provider) => {
    return BridgeHelper._calculateRetryableHashInternal(inboxSequenceNumber, chainIdOrL2Provider, 0);
};
BridgeHelper.calculateRetryableAutoRedeemTxnHash = async (inboxSequenceNumber, chainIdOrL2Provider) => {
    return BridgeHelper._calculateRetryableHashInternal(inboxSequenceNumber, chainIdOrL2Provider, 1);
};
BridgeHelper.waitForRetryableReceipt = async (seqNum, l2Provider) => {
    const l2RetryableHash = await BridgeHelper.calculateL2RetryableTransactionHash(seqNum, l2Provider);
    return l2Provider.waitForTransaction(l2RetryableHash);
};
BridgeHelper.getL2Transaction = async (l2TransactionHash, l2Provider) => {
    const txReceipt = await l2Provider.getTransactionReceipt(l2TransactionHash);
    if (!txReceipt)
        throw new Error("Can't find L2 transaction receipt?");
    return txReceipt;
};
BridgeHelper.getL1Transaction = async (l1TransactionHash, l1Provider) => {
    const txReceipt = await l1Provider.getTransactionReceipt(l1TransactionHash);
    if (!txReceipt)
        throw new Error("Can't find L1 transaction receipt?");
    return txReceipt;
};
BridgeHelper.getBuddyDeployInL2Transaction = async (l2Transaction) => {
    const iface = new ethers_2.utils.Interface([
        `event Deployed(address indexed _sender, address indexed _contract, uint256 indexed withdrawalId, bool _success)`,
    ]);
    const DeployedEvent = iface.getEvent('Deployed');
    const eventTopic = iface.getEventTopic(DeployedEvent);
    const logs = l2Transaction.logs.filter(log => log.topics[0] === eventTopic);
    return logs.map(log => iface.parseLog(log).args);
};
BridgeHelper.getDepositTokenEventData = async (l1Transaction, l1GatewayAddress) => {
    const factory = new L1ERC20Gateway__factory_1.L1ERC20Gateway__factory();
    const contract = factory.attach(l1GatewayAddress);
    const iface = contract.interface;
    const event = iface.getEvent('DepositInitiated');
    const eventTopic = iface.getEventTopic(event);
    const logs = l1Transaction.logs.filter(log => log.topics[0] === eventTopic);
    return logs.map(log => iface.parseLog(log).args);
};
BridgeHelper.getEventLogs = (eventName, connectedContract, topics = [], filter = {}) => {
    const iface = connectedContract.interface;
    const event = iface.getEvent(eventName);
    const eventTopic = iface.getEventTopic(event);
    return connectedContract.provider.getLogs({
        address: connectedContract.address,
        topics: [eventTopic, ...topics],
        fromBlock: filter.fromBlock || 0,
        toBlock: filter.toBlock || 'latest',
    });
};
BridgeHelper.getGatewaySetEventData = async (gatewayRouterAddress, provider) => {
    const contract = L1GatewayRouter__factory_1.L1GatewayRouter__factory.connect(gatewayRouterAddress, provider);
    const logs = await BridgeHelper.getEventLogs('GatewaySet', contract);
    return logs.map(log => contract.interface.parseLog(log).args);
};
BridgeHelper.getWithdrawalsInL2Transaction = (l2Transaction, l2Provider) => {
    const contract = ArbSys__factory_1.ArbSys__factory.connect(precompile_addresses_1.ARB_SYS_ADDRESS, l2Provider);
    const iface = contract.interface;
    const l2ToL1Event = iface.getEvent('L2ToL1Transaction');
    const eventTopic = iface.getEventTopic(l2ToL1Event);
    const logs = l2Transaction.logs.filter(log => log.topics[0] === eventTopic);
    return logs.map(log => iface.parseLog(log).args);
};
BridgeHelper.getCoreBridgeFromInbox = (inboxAddress, l1Provider) => {
    const contract = Inbox__factory_1.Inbox__factory.connect(inboxAddress, l1Provider);
    return contract.functions.bridge().then(([res]) => res);
};
BridgeHelper.getInboxSeqNumFromContractTransaction = async (l1Transaction, inboxAddress) => {
    const factory = new Inbox__factory_1.Inbox__factory();
    const contract = factory.attach(inboxAddress);
    const iface = contract.interface;
    const messageDelivered = iface.getEvent('InboxMessageDelivered');
    const messageDeliveredFromOrigin = iface.getEvent('InboxMessageDeliveredFromOrigin');
    const eventTopics = {
        InboxMessageDelivered: iface.getEventTopic(messageDelivered),
        InboxMessageDeliveredFromOrigin: iface.getEventTopic(messageDeliveredFromOrigin),
    };
    const logs = l1Transaction.logs.filter(log => log.topics[0] === eventTopics.InboxMessageDelivered ||
        log.topics[0] === eventTopics.InboxMessageDeliveredFromOrigin);
    if (logs.length === 0)
        return undefined;
    return logs.map(log => ethers_3.BigNumber.from(log.topics[1]));
};
/**
 * Attempt to retrieve data necessary to execute outbox message; available before outbox entry is created /confirmed
 */
BridgeHelper.tryGetProof = async (batchNumber, indexInBatch, l2Provider, retryDelay = 500) => {
    const contractInterface = new ethers_2.utils.Interface([
        `function lookupMessageBatchProof(uint256 batchNum, uint64 index)
          external
          view
          returns (
              bytes32[] memory proof,
              uint256 path,
              address l2Sender,
              address l1Dest,
              uint256 l2Block,
              uint256 l1Block,
              uint256 timestamp,
              uint256 amount,
              bytes memory calldataForL1
          )`,
    ]);
    const nodeInterface = new ethers_3.Contract(precompile_addresses_1.NODE_INTERFACE_ADDRESS, contractInterface).connect(l2Provider);
    try {
        const res = await nodeInterface.callStatic.lookupMessageBatchProof(batchNumber, indexInBatch);
        return res;
    }
    catch (e) {
        const expectedError = "batch doesn't exist";
        const actualError = e && (e.message || (e.error && e.error.message));
        if (actualError.includes(expectedError)) {
            console.log('Withdrawal detected, but batch not created yet. Going to wait a bit.');
        }
        else {
            console.log("Withdrawal proof didn't work. Not sure why");
            console.log(e);
            console.log('Going to try again after waiting');
        }
        await BridgeHelper.wait(retryDelay);
        console.log('New attempt starting');
        // TODO: should exponential backoff?
        return BridgeHelper.tryGetProof(batchNumber, indexInBatch, l2Provider, retryDelay);
    }
};
BridgeHelper.wait = (ms) => new Promise(res => setTimeout(res, ms));
BridgeHelper.tryGetProofOnce = async (batchNumber, indexInBatch, l2Provider) => {
    const contractInterface = new ethers_2.utils.Interface([
        `function lookupMessageBatchProof(uint256 batchNum, uint64 index)
          external
          view
          returns (
              bytes32[] memory proof,
              uint256 path,
              address l2Sender,
              address l1Dest,
              uint256 l2Block,
              uint256 l1Block,
              uint256 timestamp,
              uint256 amount,
              bytes memory calldataForL1
          )`,
    ]);
    const nodeInterface = new ethers_3.Contract(precompile_addresses_1.NODE_INTERFACE_ADDRESS, contractInterface).connect(l2Provider);
    try {
        const res = await nodeInterface.callStatic.lookupMessageBatchProof(batchNumber, indexInBatch);
        return res;
    }
    catch (e) {
        const expectedError = "batch doesn't exist";
        const actualError = e && (e.message || (e.error && e.error.message));
        if (actualError.includes(expectedError)) {
            console.log('Withdrawal detected, but batch not created yet.');
        }
        else {
            console.log("Withdrawal proof didn't work. Not sure why");
            console.log(e);
        }
    }
    return null;
};
BridgeHelper.outboxEntryExists = (batchNumber, outboxAddress, l1Provider) => {
    const outbox = IOutbox__factory_1.IOutbox__factory.connect(outboxAddress, l1Provider);
    return outbox.outboxEntryExists(batchNumber);
};
BridgeHelper.waitUntilOutboxEntryCreated = async (batchNumber, outboxAddress, l1Provider, retryDelay = 500) => {
    const exists = await BridgeHelper.outboxEntryExists(batchNumber, outboxAddress, l1Provider);
    if (exists) {
        console.log('Found outbox entry!');
        return;
    }
    else {
        console.log("can't find entry, lets wait a bit?");
        await BridgeHelper.wait(retryDelay);
        console.log('Starting new attempt');
        await BridgeHelper.waitUntilOutboxEntryCreated(batchNumber, outboxAddress, l1Provider, retryDelay);
    }
};
BridgeHelper.getActiveOutbox = async (rollupAddress, l1Provider) => {
    return Rollup__factory_1.Rollup__factory.connect(rollupAddress, l1Provider).outbox();
};
BridgeHelper.tryOutboxExecute = async (outboxProofData, outboxAddress, l1Signer) => {
    if (!l1Signer.provider)
        throw new Error('No L1 provider in L1 signer');
    await BridgeHelper.waitUntilOutboxEntryCreated(outboxProofData.batchNumber, outboxAddress, l1Signer.provider);
    const outbox = Outbox__factory_1.Outbox__factory.connect(outboxAddress, l1Signer);
    try {
        // TODO: wait until assertion is confirmed before execute
        // We can predict and print number of missing blocks
        // if not challenged
        const outboxExecute = await outbox.functions.executeTransaction(outboxProofData.batchNumber, outboxProofData.proof, outboxProofData.path, outboxProofData.l2Sender, outboxProofData.l1Dest, outboxProofData.l2Block, outboxProofData.l1Block, outboxProofData.timestamp, outboxProofData.amount, outboxProofData.calldataForL1);
        console.log(`Transaction hash: ${outboxExecute.hash}`);
        return outboxExecute;
    }
    catch (e) {
        console.log('failed to execute tx in layer 1');
        console.log(e);
        // TODO: should we just try again after delay instead of throwing?
        throw e;
    }
};
BridgeHelper.triggerL2ToL1Transaction = async (batchNumber, indexInBatch, outboxAddress, l2Provider, l1Signer, singleAttempt = false) => {
    const l1Provider = l1Signer.provider;
    if (!l1Provider)
        throw new Error('Signer must be connected to L2 provider');
    console.log('going to get proof');
    let res;
    if (singleAttempt) {
        const outGoingMessageState = await BridgeHelper.getOutGoingMessageState(batchNumber, indexInBatch, outboxAddress, l1Provider, l2Provider);
        const infoString = `batchNumber: ${batchNumber.toNumber()} indexInBatch: ${indexInBatch.toNumber()}`;
        switch (outGoingMessageState) {
            case OutgoingMessageState.NOT_FOUND:
                throw new Error(`Outgoing message not found. ${infoString}`);
            case OutgoingMessageState.UNCONFIRMED:
                throw new Error(`Attempting to execute message that isn't yet confirmed. ${infoString}`);
            case OutgoingMessageState.EXECUTED:
                throw new Error(`Message already executed ${infoString}`);
            case OutgoingMessageState.CONFIRMED: {
                const _res = await BridgeHelper.tryGetProofOnce(batchNumber, indexInBatch, l2Provider);
                if (_res === null)
                    throw new Error(`666: message is in a confirmed node but lookupMessageBatchProof returned null (!) ${infoString}`);
                res = _res;
                break;
            }
        }
    }
    else {
        res = await BridgeHelper.tryGetProof(batchNumber, indexInBatch, l2Provider);
    }
    const proofData = Object.assign(Object.assign({}, res), { batchNumber });
    console.log('got proof');
    return BridgeHelper.tryOutboxExecute(proofData, outboxAddress, l1Signer);
};
BridgeHelper.getL2ToL1EventData = async (fromAddress, l2Provider, filter) => {
    const contract = ArbSys__factory_1.ArbSys__factory.connect(precompile_addresses_1.ARB_SYS_ADDRESS, l2Provider);
    const logs = await BridgeHelper.getEventLogs('L2ToL1Transaction', contract, [ethers_1.ethers.utils.hexZeroPad(fromAddress, 32)], filter);
    return logs.map(log => contract.interface.parseLog(log).args);
};
/**
 * Check if given assertion has been confirmed
 */
BridgeHelper.assertionIsConfirmed = async (nodeNum, rollupAddress, l1Provider) => {
    const contract = Rollup__factory_1.Rollup__factory.connect(rollupAddress, l1Provider);
    const logs = await BridgeHelper.getEventLogs('NodeConfirmed', contract, [
        ethers_1.ethers.utils.hexZeroPad(nodeNum.toHexString(), 32),
    ]);
    return logs.length === 1;
};
BridgeHelper.getNodeCreatedEvents = (rollupAddress, l1Provider) => {
    const contract = Rollup__factory_1.Rollup__factory.connect(rollupAddress, l1Provider);
    return BridgeHelper.getEventLogs('NodeCreated', contract);
};
BridgeHelper.getOutgoingMessage = async (batchNumber, indexInBatch, l2Provider) => {
    const contract = ArbSys__factory_1.ArbSys__factory.connect(precompile_addresses_1.ARB_SYS_ADDRESS, l2Provider);
    const topics = [
        null,
        null,
        ethers_1.ethers.utils.hexZeroPad(batchNumber.toHexString(), 32),
    ];
    const logs = await BridgeHelper.getEventLogs('L2ToL1Transaction', contract, 
    // @ts-ignore
    topics);
    const parsedData = logs.map(log => contract.interface.parseLog(log).args);
    return parsedData.filter(log => log.indexInBatch.eq(indexInBatch));
};
/**
 * Get outgoing message Id (key to in OutboxEntry.spentOutput)
 */
BridgeHelper.calculateOutgoingMessageId = (path, proofLength) => {
    return ethers_2.utils.keccak256(ethers_2.utils.defaultAbiCoder.encode(['uint256', 'uint256'], [path, proofLength]));
};
/**
 * Check if given outbox message has already been executed
 */
BridgeHelper.messageHasExecuted = async (batchNumber, path, outboxAddress, l1Provider) => {
    const contract = Outbox__factory_1.Outbox__factory.connect(outboxAddress, l1Provider);
    const topics = [
        null,
        null,
        ethers_1.ethers.utils.hexZeroPad(batchNumber.toHexString(), 32),
    ];
    const logs = await BridgeHelper.getEventLogs('OutBoxTransactionExecuted', contract, 
    // @ts-ignore
    topics);
    const parsedData = logs.map(log => contract.interface.parseLog(log)
        .args);
    return (parsedData.filter(executedEvent => executedEvent.transactionIndex.eq(path)).length === 1);
};
BridgeHelper.getOutGoingMessageState = async (batchNumber, indexInBatch, outBoxAddress, l1Provider, l2Provider) => {
    try {
        const proofData = await BridgeHelper.tryGetProofOnce(batchNumber, indexInBatch, l2Provider);
        if (!proofData) {
            return OutgoingMessageState.UNCONFIRMED;
        }
        const messageExecuted = await BridgeHelper.messageHasExecuted(batchNumber, proofData.path, outBoxAddress, l1Provider);
        if (messageExecuted) {
            return OutgoingMessageState.EXECUTED;
        }
        const outboxEntryExists = await BridgeHelper.outboxEntryExists(batchNumber, outBoxAddress, l1Provider);
        return outboxEntryExists
            ? OutgoingMessageState.CONFIRMED
            : OutgoingMessageState.UNCONFIRMED;
    }
    catch (e) {
        console.warn('666: error in getOutGoingMessageState:', e);
        return OutgoingMessageState.NOT_FOUND;
    }
};
