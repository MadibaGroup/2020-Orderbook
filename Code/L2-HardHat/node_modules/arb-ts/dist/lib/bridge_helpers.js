"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeHelper = exports.TransactionOverrides = exports.addressToSymbol = void 0;
var ethers_1 = require("ethers");
var ArbTokenBridge__factory_1 = require("./abi/factories/ArbTokenBridge__factory");
var EthERC20Bridge__factory_1 = require("./abi/factories/EthERC20Bridge__factory");
var Outbox__factory_1 = require("./abi/factories/Outbox__factory");
var Bridge__factory_1 = require("./abi/factories/Bridge__factory");
var Inbox__factory_1 = require("./abi/factories/Inbox__factory");
var ArbSys__factory_1 = require("./abi/factories/ArbSys__factory");
var ethers_2 = require("ethers");
var ethers_3 = require("ethers");
var l2Bridge_1 = require("./l2Bridge");
var addressToSymbol = function (erc20L1Address) {
    return erc20L1Address.substr(erc20L1Address.length - 3).toUpperCase() + '?';
};
exports.addressToSymbol = addressToSymbol;
var TransactionOverrides = /** @class */ (function () {
    function TransactionOverrides() {
    }
    return TransactionOverrides;
}());
exports.TransactionOverrides = TransactionOverrides;
var NODE_INTERFACE_ADDRESS = '0x00000000000000000000000000000000000000C8';
var BridgeHelper = /** @class */ (function () {
    function BridgeHelper() {
    }
    BridgeHelper.getTokenWithdrawEventData = function (destinationAddress, l2BridgeAddr, l2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var contract, iface, tokenWithdrawEvent, tokenWithdrawTopic, topics, logs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    contract = ArbTokenBridge__factory_1.ArbTokenBridge__factory.connect(l2BridgeAddr, l2Provider);
                    iface = contract.interface;
                    tokenWithdrawEvent = iface.getEvent('WithdrawToken');
                    tokenWithdrawTopic = iface.getEventTopic(tokenWithdrawEvent);
                    topics = [
                        tokenWithdrawTopic,
                        null,
                        null,
                        ethers_2.utils.hexZeroPad(destinationAddress, 32),
                    ];
                    return [4 /*yield*/, l2Provider.getLogs({
                            address: l2BridgeAddr,
                            // @ts-ignore
                            topics: topics,
                            fromBlock: 0,
                            toBlock: 'latest',
                        })];
                case 1:
                    logs = _a.sent();
                    return [2 /*return*/, logs.map(function (log) {
                            var data = __assign(__assign({}, iface.parseLog(log).args), { txHash: log.transactionHash });
                            return data;
                        })];
            }
        });
    }); };
    BridgeHelper.calculateL2TransactionHash = function (inboxSequenceNumber, chainIdOrL2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var l2ChainId, _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!ethers_3.BigNumber.isBigNumber(chainIdOrL2Provider)) return [3 /*break*/, 1];
                    _a = chainIdOrL2Provider;
                    return [3 /*break*/, 3];
                case 1:
                    _c = (_b = ethers_3.BigNumber).from;
                    return [4 /*yield*/, chainIdOrL2Provider.getNetwork()];
                case 2:
                    _a = _c.apply(_b, [(_d.sent()).chainId]);
                    _d.label = 3;
                case 3:
                    l2ChainId = _a;
                    return [2 /*return*/, ethers_2.utils.keccak256(ethers_2.utils.concat([
                            ethers_2.utils.zeroPad(l2ChainId.toHexString(), 32),
                            ethers_2.utils.zeroPad(inboxSequenceNumber.toHexString(), 32),
                        ]))];
            }
        });
    }); };
    BridgeHelper.calculateL2RetryableTransactionHash = function (inboxSequenceNumber, chainIdOrL2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var requestID;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, BridgeHelper.calculateL2TransactionHash(inboxSequenceNumber, chainIdOrL2Provider)];
                case 1:
                    requestID = _a.sent();
                    return [2 /*return*/, ethers_2.utils.keccak256(ethers_2.utils.concat([
                            ethers_2.utils.zeroPad(requestID, 32),
                            ethers_2.utils.zeroPad(ethers_3.BigNumber.from(1).toHexString(), 32),
                        ]))];
            }
        });
    }); };
    BridgeHelper.waitForRetriableReceipt = function (seqNum, l2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var l2RetriableHash;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, BridgeHelper.calculateL2RetryableTransactionHash(seqNum, l2Provider)];
                case 1:
                    l2RetriableHash = _a.sent();
                    return [2 /*return*/, l2Provider.waitForTransaction(l2RetriableHash)];
            }
        });
    }); };
    BridgeHelper.getL2Transaction = function (l2TransactionHash, l2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var txReceipt;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, l2Provider.getTransactionReceipt(l2TransactionHash)];
                case 1:
                    txReceipt = _a.sent();
                    if (!txReceipt)
                        throw new Error("Can't find L2 transaction receipt?");
                    return [2 /*return*/, txReceipt];
            }
        });
    }); };
    BridgeHelper.getL1Transaction = function (l1TransactionHash, l1Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var txReceipt;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, l1Provider.getTransactionReceipt(l1TransactionHash)];
                case 1:
                    txReceipt = _a.sent();
                    if (!txReceipt)
                        throw new Error("Can't find L1 transaction receipt?");
                    return [2 /*return*/, txReceipt];
            }
        });
    }); };
    BridgeHelper.getBuddyDeployInL2Transaction = function (l2Transaction) { return __awaiter(void 0, void 0, void 0, function () {
        var iface, DeployedEvent, eventTopic, logs;
        return __generator(this, function (_a) {
            iface = new ethers_2.utils.Interface([
                "event Deployed(address indexed _sender, address indexed _contract, uint256 indexed withdrawalId, bool _success)",
            ]);
            DeployedEvent = iface.getEvent('Deployed');
            eventTopic = iface.getEventTopic(DeployedEvent);
            logs = l2Transaction.logs.filter(function (log) { return log.topics[0] === eventTopic; });
            return [2 /*return*/, logs.map(function (log) { return iface.parseLog(log).args; })];
        });
    }); };
    BridgeHelper.getDepositTokenEventData = function (l1Transaction, l2BridgeAddress) { return __awaiter(void 0, void 0, void 0, function () {
        var factory, contract, iface, event, eventTopic, logs;
        return __generator(this, function (_a) {
            factory = new EthERC20Bridge__factory_1.EthERC20Bridge__factory();
            contract = factory.attach(l2BridgeAddress);
            iface = contract.interface;
            event = iface.getEvent('DepositToken');
            eventTopic = iface.getEventTopic(event);
            logs = l1Transaction.logs.filter(function (log) { return log.topics[0] === eventTopic; });
            return [2 /*return*/, logs.map(function (log) { return iface.parseLog(log).args; })];
        });
    }); };
    BridgeHelper.getActivateCustomTokenEventResult = function (l1Transaction, l1BridgeAddress) { return __awaiter(void 0, void 0, void 0, function () {
        var factory, contract, iface, event, eventTopic, logs;
        return __generator(this, function (_a) {
            factory = new EthERC20Bridge__factory_1.EthERC20Bridge__factory();
            contract = factory.attach(l1BridgeAddress);
            iface = contract.interface;
            event = iface.getEvent('ActivateCustomToken');
            eventTopic = iface.getEventTopic(event);
            logs = l1Transaction.logs.filter(function (log) {
                return log.topics[0] === eventTopic;
            });
            return [2 /*return*/, logs.map(function (log) { return iface.parseLog(log).args; })];
        });
    }); };
    BridgeHelper.getWithdrawalsInL2Transaction = function (l2Transaction, l2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var contract, iface, l2ToL1Event, eventTopic, logs;
        return __generator(this, function (_a) {
            contract = ArbSys__factory_1.ArbSys__factory.connect(l2Bridge_1.ARB_SYS_ADDRESS, l2Provider);
            iface = contract.interface;
            l2ToL1Event = iface.getEvent('L2ToL1Transaction');
            eventTopic = iface.getEventTopic(l2ToL1Event);
            logs = l2Transaction.logs.filter(function (log) { return log.topics[0] === eventTopic; });
            return [2 /*return*/, logs.map(function (log) { return iface.parseLog(log).args; })];
        });
    }); };
    BridgeHelper.getCoreBridgeFromInbox = function (inboxAddress, l1Provider) {
        var contract = Inbox__factory_1.Inbox__factory.connect(inboxAddress, l1Provider);
        return contract.bridge();
    };
    BridgeHelper.getInboxSeqNumFromContractTransaction = function (l2Transaction, inboxAddress) { return __awaiter(void 0, void 0, void 0, function () {
        var factory, contract, iface, messageDelivered, messageDeliveredFromOrigin, eventTopics, logs;
        return __generator(this, function (_a) {
            factory = new Inbox__factory_1.Inbox__factory();
            contract = factory.attach(inboxAddress);
            iface = contract.interface;
            messageDelivered = iface.getEvent('InboxMessageDelivered');
            messageDeliveredFromOrigin = iface.getEvent('InboxMessageDeliveredFromOrigin');
            eventTopics = {
                InboxMessageDelivered: iface.getEventTopic(messageDelivered),
                InboxMessageDeliveredFromOrigin: iface.getEventTopic(messageDeliveredFromOrigin),
            };
            logs = l2Transaction.logs.filter(function (log) {
                return log.topics[0] === eventTopics.InboxMessageDelivered ||
                    log.topics[0] === eventTopics.InboxMessageDeliveredFromOrigin;
            });
            if (logs.length === 0)
                return [2 /*return*/, undefined];
            return [2 /*return*/, logs.map(function (log) { return ethers_3.BigNumber.from(log.topics[1]); })];
        });
    }); };
    BridgeHelper.tryGetProof = function (batchNumber, indexInBatch, l2Provider, retryDelay) {
        if (retryDelay === void 0) { retryDelay = 500; }
        return __awaiter(void 0, void 0, void 0, function () {
            var contractInterface, nodeInterface, res, e_1, expectedError;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        contractInterface = new ethers_2.utils.Interface([
                            "function lookupMessageBatchProof(uint256 batchNum, uint64 index)\n          external\n          view\n          returns (\n              bytes32[] memory proof,\n              uint256 path,\n              address l2Sender,\n              address l1Dest,\n              uint256 l2Block,\n              uint256 l1Block,\n              uint256 timestamp,\n              uint256 amount,\n              bytes memory calldataForL1\n          )",
                        ]);
                        nodeInterface = new ethers_3.Contract(NODE_INTERFACE_ADDRESS, contractInterface).connect(l2Provider);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 5]);
                        return [4 /*yield*/, nodeInterface.callStatic.lookupMessageBatchProof(batchNumber, indexInBatch)];
                    case 2:
                        res = _a.sent();
                        return [2 /*return*/, res];
                    case 3:
                        e_1 = _a.sent();
                        expectedError = "batch doesn't exist";
                        if (e_1 &&
                            e_1.error &&
                            e_1.error.message &&
                            e_1.error.message === expectedError) {
                            console.log('Withdrawal detected, but batch not created yet. Going to wait a bit.');
                        }
                        else {
                            console.log("Withdrawal proof didn't work. Not sure why");
                            console.log(e_1);
                            console.log('Going to try again after waiting');
                        }
                        return [4 /*yield*/, BridgeHelper.wait(retryDelay)];
                    case 4:
                        _a.sent();
                        console.log('New attempt starting');
                        // TODO: should exponential backoff?
                        return [2 /*return*/, BridgeHelper.tryGetProof(batchNumber, indexInBatch, l2Provider, retryDelay)];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    BridgeHelper.wait = function (ms) { return new Promise(function (res) { return setTimeout(res, ms); }); };
    BridgeHelper.tryGetProofOnce = function (batchNumber, indexInBatch, l2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var nodeInterfaceAddress, contractInterface, nodeInterface, res, e_2, expectedError;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    nodeInterfaceAddress = '0x00000000000000000000000000000000000000C8';
                    contractInterface = new ethers_2.utils.Interface([
                        "function lookupMessageBatchProof(uint256 batchNum, uint64 index)\n          external\n          view\n          returns (\n              bytes32[] memory proof,\n              uint256 path,\n              address l2Sender,\n              address l1Dest,\n              uint256 l2Block,\n              uint256 l1Block,\n              uint256 timestamp,\n              uint256 amount,\n              bytes memory calldataForL1\n          )",
                    ]);
                    nodeInterface = new ethers_3.Contract(nodeInterfaceAddress, contractInterface).connect(l2Provider);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, nodeInterface.callStatic.lookupMessageBatchProof(batchNumber, indexInBatch)];
                case 2:
                    res = _a.sent();
                    return [2 /*return*/, res];
                case 3:
                    e_2 = _a.sent();
                    expectedError = "batch doesn't exist";
                    if (e_2 &&
                        e_2.error &&
                        e_2.error.message &&
                        e_2.error.message === expectedError) {
                        console.log('Withdrawal detected, but batch not created yet.');
                    }
                    else {
                        console.log("Withdrawal proof didn't work. Not sure why");
                        console.log(e_2);
                    }
                    return [3 /*break*/, 4];
                case 4: return [2 /*return*/, null];
            }
        });
    }); };
    BridgeHelper.getOutboxEntry = function (batchNumber, outboxAddress, l1Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var iface, outbox;
        return __generator(this, function (_a) {
            iface = new ethers_1.ethers.utils.Interface([
                'function outboxes(uint256) public view returns (address)',
            ]);
            outbox = new ethers_1.ethers.Contract(outboxAddress, iface).connect(l1Provider);
            return [2 /*return*/, outbox.outboxes(batchNumber)];
        });
    }); };
    BridgeHelper.waitUntilOutboxEntryCreated = function (batchNumber, activeOutboxAddress, l1Provider, retryDelay) {
        if (retryDelay === void 0) { retryDelay = 500; }
        return __awaiter(void 0, void 0, void 0, function () {
            var expectedEntry, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 4]);
                        return [4 /*yield*/, BridgeHelper.getOutboxEntry(batchNumber, activeOutboxAddress, l1Provider)];
                    case 1:
                        expectedEntry = _a.sent();
                        console.log('Found entry index!');
                        return [2 /*return*/, expectedEntry];
                    case 2:
                        e_3 = _a.sent();
                        console.log("can't find entry, lets wait a bit?");
                        if (e_3.message === 'invalid opcode: opcode 0xfe not defined') {
                            console.log('Array out of bounds, wait until the entry is posted');
                        }
                        else {
                            console.log(e_3);
                            console.log(e_3.message);
                        }
                        return [4 /*yield*/, BridgeHelper.wait(retryDelay)];
                    case 3:
                        _a.sent();
                        console.log('Starting new attempt');
                        return [2 /*return*/, BridgeHelper.waitUntilOutboxEntryCreated(batchNumber, activeOutboxAddress, l1Provider, retryDelay)];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    BridgeHelper.getActiveOutbox = function (l1CoreBridgeAddress, l1Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var bridge, activeOutboxAddress, e_4;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Bridge__factory_1.Bridge__factory.connect(l1CoreBridgeAddress, l1Provider)];
                case 1:
                    bridge = _a.sent();
                    return [4 /*yield*/, bridge.allowedOutboxList(0)];
                case 2:
                    activeOutboxAddress = _a.sent();
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    // index 1 should not exist
                    return [4 /*yield*/, bridge.allowedOutboxList(1)];
                case 4:
                    // index 1 should not exist
                    _a.sent();
                    console.error('There is more than 1 outbox registered with the bridge?!');
                    return [3 /*break*/, 6];
                case 5:
                    e_4 = _a.sent();
                    // this should fail!
                    console.log('All is good');
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/, activeOutboxAddress];
            }
        });
    }); };
    BridgeHelper.tryOutboxExecute = function (outboxProofData, l1CoreBridgeAddress, l1Signer) { return __awaiter(void 0, void 0, void 0, function () {
        var activeOutboxAddress, outbox, outboxExecute, receipt, e_5;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!l1Signer.provider)
                        throw new Error('No L1 provider in L1 signer');
                    return [4 /*yield*/, BridgeHelper.getActiveOutbox(l1CoreBridgeAddress, l1Signer.provider)];
                case 1:
                    activeOutboxAddress = _a.sent();
                    return [4 /*yield*/, BridgeHelper.waitUntilOutboxEntryCreated(outboxProofData.batchNumber, activeOutboxAddress, l1Signer.provider)];
                case 2:
                    _a.sent();
                    outbox = Outbox__factory_1.Outbox__factory.connect(activeOutboxAddress, l1Signer);
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 6, , 7]);
                    return [4 /*yield*/, outbox.executeTransaction(outboxProofData.batchNumber, outboxProofData.proof, outboxProofData.path, outboxProofData.l2Sender, outboxProofData.l1Dest, outboxProofData.l2Block, outboxProofData.l1Block, outboxProofData.timestamp, outboxProofData.amount, outboxProofData.calldataForL1)];
                case 4:
                    outboxExecute = _a.sent();
                    console.log("Transaction hash: " + outboxExecute.hash);
                    console.log('Waiting for receipt');
                    return [4 /*yield*/, outboxExecute.wait()];
                case 5:
                    receipt = _a.sent();
                    console.log('Receipt emitted');
                    return [2 /*return*/, receipt];
                case 6:
                    e_5 = _a.sent();
                    console.log('failed to execute tx in layer 1');
                    console.log(e_5);
                    // TODO: should we just try again after delay instead of throwing?
                    throw e_5;
                case 7: return [2 /*return*/];
            }
        });
    }); };
    BridgeHelper.triggerL2ToL1Transaction = function (batchNumber, indexInBatch, l1CoreBridgeAddress, l2Provider, l1Signer, singleAttempt) {
        if (singleAttempt === void 0) { singleAttempt = false; }
        return __awaiter(void 0, void 0, void 0, function () {
            var res, _res, proofData, outboxExecuteTransactionReceipt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!l1Signer.provider)
                            throw new Error('Signer must be connected to L2 provider');
                        console.log('going to get proof');
                        if (!singleAttempt) return [3 /*break*/, 2];
                        return [4 /*yield*/, BridgeHelper.tryGetProofOnce(batchNumber, indexInBatch, l2Provider)];
                    case 1:
                        _res = _a.sent();
                        if (_res === null) {
                            throw new Error('Proof not found');
                        }
                        res = _res;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, BridgeHelper.tryGetProof(batchNumber, indexInBatch, l2Provider)];
                    case 3:
                        res = _a.sent();
                        _a.label = 4;
                    case 4:
                        proofData = __assign(__assign({}, res), { batchNumber: batchNumber });
                        console.log('got proof');
                        return [4 /*yield*/, BridgeHelper.tryOutboxExecute(proofData, l1CoreBridgeAddress, l1Signer)];
                    case 5:
                        outboxExecuteTransactionReceipt = _a.sent();
                        return [2 /*return*/, outboxExecuteTransactionReceipt];
                }
            });
        });
    };
    BridgeHelper.getL2ToL1EventData = function (destinationAddress, l2Provider) { return __awaiter(void 0, void 0, void 0, function () {
        var contract, iface, l2ToL1TransactionEvent, l2ToL1TransactionTopic, topics, logs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    contract = ArbSys__factory_1.ArbSys__factory.connect(l2Bridge_1.ARB_SYS_ADDRESS, l2Provider);
                    iface = contract.interface;
                    l2ToL1TransactionEvent = iface.getEvent('L2ToL1Transaction');
                    l2ToL1TransactionTopic = iface.getEventTopic(l2ToL1TransactionEvent);
                    topics = [
                        l2ToL1TransactionTopic,
                        ethers_1.ethers.utils.hexZeroPad(destinationAddress, 32),
                    ];
                    return [4 /*yield*/, l2Provider.getLogs({
                            address: l2Bridge_1.ARB_SYS_ADDRESS,
                            topics: topics,
                            fromBlock: 0,
                            toBlock: 'latest',
                        })];
                case 1:
                    logs = _a.sent();
                    return [2 /*return*/, logs.map(function (log) { return iface.parseLog(log).args; })];
            }
        });
    }); };
    return BridgeHelper;
}());
exports.BridgeHelper = BridgeHelper;
