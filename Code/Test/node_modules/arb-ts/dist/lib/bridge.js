/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bridge = void 0;
const ethers_1 = require("ethers");
const l1Bridge_1 = require("./l1Bridge");
const l2Bridge_1 = require("./l2Bridge");
const bridge_helpers_1 = require("./bridge_helpers");
const precompile_addresses_1 = require("./precompile_addresses");
const NodeInterface__factory_1 = require("./abi/factories/NodeInterface__factory");
const L1ERC20Gateway__factory_1 = require("./abi/factories/L1ERC20Gateway__factory");
const L1WethGateway__factory_1 = require("./abi/factories/L1WethGateway__factory");
const Inbox__factory_1 = require("./abi/factories/Inbox__factory");
const Bridge__factory_1 = require("./abi/factories/Bridge__factory");
const OldOutbox__factory_1 = require("./abi/factories/OldOutbox__factory");
const networks_1 = __importDefault(require("./networks"));
const DEFAULT_SUBMISSION_PERCENT_INCREASE = ethers_1.BigNumber.from(400);
/**
 * Main class for accessing token bridge methods; inherits methods from {@link L1Bridge} and {@link L2Bridge}
 */
class Bridge {
    constructor(l1BridgeObj, l2BridgeObj, isCustomNetwork = false) {
        this.l1Bridge = l1BridgeObj;
        this.l2Bridge = l2BridgeObj;
        this.isCustomNetwork = isCustomNetwork;
    }
    updateAllBalances() {
        this.updateAllTokens();
        this.getL1EthBalance();
        this.getL2EthBalance();
    }
    static async init(ethSigner, arbSigner, l1GatewayRouterAddress, l2GatewayRouterAddress) {
        if (!ethSigner.provider || !arbSigner.provider) {
            throw new Error('Signer needs a provider');
        }
        const l1ChainId = await ethSigner.getChainId();
        const l2ChainId = await arbSigner.getChainId();
        const l1Network = networks_1.default[l1ChainId];
        const l2Network = networks_1.default[l2ChainId];
        let isCustomNetwork = false;
        if (l1Network && l2Network) {
            if (l1Network.partnerChainID !== l2Network.chainID)
                throw new Error('L1 and L2 networks are not connected');
            if (l1Network.isArbitrum)
                throw new Error('Connected to an Arbitrum networks as the L1...');
            if (!l2Network.isArbitrum)
                throw new Error('Connected to an L1 network as the L2...');
            l1GatewayRouterAddress = l1Network.tokenBridge.l1GatewayRouter;
            l2GatewayRouterAddress = l2Network.tokenBridge.l2GatewayRouter;
        }
        else {
            isCustomNetwork = true;
        }
        if (!l2GatewayRouterAddress)
            throw new Error('Network not in config, and no l2GatewayRouter address provided');
        if (!l1GatewayRouterAddress)
            throw new Error('Network not in config, and no l1GatewayRouter Address provided');
        // check routers are deployed
        const l1RouterCode = await ethSigner.provider.getCode(l1GatewayRouterAddress);
        if (l1RouterCode === '0x') {
            throw new Error(`No code deployed to ${l1GatewayRouterAddress} in the L1`);
        }
        const l2RouterCode = await arbSigner.provider.getCode(l2GatewayRouterAddress);
        if (l2RouterCode === '0x') {
            throw new Error(`No code deployed to ${l2GatewayRouterAddress} in the L2`);
        }
        const l1BridgeObj = new l1Bridge_1.L1Bridge(l1GatewayRouterAddress, ethSigner);
        const l2BridgeObj = new l2Bridge_1.L2Bridge(l2GatewayRouterAddress, arbSigner);
        return new Bridge(l1BridgeObj, l2BridgeObj, isCustomNetwork);
    }
    /**
     * Update state of all tracked tokens (balance, allowance), etc. and returns state
     */
    async updateAllTokens() {
        const l1Tokens = await this.l1Bridge.updateAllL1Tokens();
        const l2Tokens = await this.l2Bridge.updateAllL2Tokens();
        return { l1Tokens, l2Tokens };
    }
    /**
     * Update target token (balance, allowance), etc. and state
     */
    async updateTokenData(erc20l1Address) {
        const l1Data = await this.getAndUpdateL1TokenData(erc20l1Address);
        const l2Data = await this.getAndUpdateL2TokenData(erc20l1Address);
        return { l1Data, l2Data };
    }
    get l1Tokens() {
        return this.l1Bridge.l1Tokens;
    }
    get l1GatewayRouter() {
        return this.l1Bridge.l1GatewayRouter;
    }
    defaultL1Gateway() {
        return this.l1Bridge.getDefaultL1Gateway();
    }
    get l1Signer() {
        return this.l1Bridge.l1Signer;
    }
    get l1Provider() {
        return this.l1Bridge.l1Provider;
    }
    get l2Provider() {
        return this.l2Bridge.l2Provider;
    }
    get l2Signer() {
        return this.l2Bridge.l2Signer;
    }
    /**
     * Set allowance for L1 router contract
     */
    async approveToken(erc20L1Address, amount, overrides) {
        return this.l1Bridge.approveToken(erc20L1Address, amount, overrides);
    }
    /**
     * Deposit ether from L1 to L2.
     */
    async depositETH(value, _maxSubmissionPricePercentIncrease, overrides) {
        const maxSubmissionPricePercentIncrease = _maxSubmissionPricePercentIncrease || DEFAULT_SUBMISSION_PERCENT_INCREASE;
        const maxSubmissionPrice = bridge_helpers_1.BridgeHelper.percentIncrease((await this.l2Bridge.getTxnSubmissionPrice(0))[0], maxSubmissionPricePercentIncrease);
        return this.l1Bridge.depositETH(value, maxSubmissionPrice, overrides);
    }
    async looksLikeWethGateway(potentialWethGatewayAddress) {
        try {
            const potentialWethGateway = L1WethGateway__factory_1.L1WethGateway__factory.connect(potentialWethGatewayAddress, this.l1Provider);
            await potentialWethGateway.l1Weth();
            return true;
        }
        catch (err) {
            if (err.code === 'CALL_EXCEPTION') {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Token deposit; if no value given, calculates and includes minimum necessary value to fund L2 side of execution
     */
    async deposit(erc20L1Address, amount, retryableGasArgs = {}, destinationAddress, overrides) {
        const l1ChainId = await this.l1Signer.getChainId();
        const { l1WethGateway: l1WethGatewayAddress } = networks_1.default[l1ChainId].tokenBridge;
        const gasPriceBid = retryableGasArgs.gasPriceBid || (await this.l2Provider.getGasPrice());
        const sender = await this.l1Signer.getAddress();
        const expectedL1GatewayAddress = await this.l1Bridge.getGatewayAddress(erc20L1Address);
        let estimateGasCallValue = ethers_1.constants.Zero;
        // if it's a weth deposit, include callvalue for the gas estimate for the retryable
        if (this.isCustomNetwork) {
            if (await this.looksLikeWethGateway(expectedL1GatewayAddress)) {
                estimateGasCallValue = amount;
            }
        }
        else if (l1WethGatewayAddress === expectedL1GatewayAddress) {
            estimateGasCallValue = amount;
        }
        const l1Gateway = L1ERC20Gateway__factory_1.L1ERC20Gateway__factory.connect(expectedL1GatewayAddress, this.l1Provider);
        const depositCalldata = await l1Gateway.getOutboundCalldata(erc20L1Address, sender, destinationAddress ? destinationAddress : sender, amount, '0x');
        const maxSubmissionPricePercentIncrease = retryableGasArgs.maxSubmissionPricePercentIncrease ||
            DEFAULT_SUBMISSION_PERCENT_INCREASE;
        const maxSubmissionPrice = bridge_helpers_1.BridgeHelper.percentIncrease((await this.l2Bridge.getTxnSubmissionPrice(depositCalldata.length - 2))[0], maxSubmissionPricePercentIncrease);
        const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(precompile_addresses_1.NODE_INTERFACE_ADDRESS, this.l2Provider);
        const l2Dest = await l1Gateway.counterpartGateway();
        const maxGas = retryableGasArgs.maxGas ||
            (await nodeInterface.estimateRetryableTicket(expectedL1GatewayAddress, ethers_1.ethers.utils.parseEther('0.05').add(estimateGasCallValue), l2Dest, estimateGasCallValue, maxSubmissionPrice, sender, sender, 0, 0, depositCalldata))[0];
        // calculate required forwarding gas
        let ethDeposit = overrides && (await overrides.value);
        if (!ethDeposit || ethers_1.BigNumber.from(ethDeposit).isZero()) {
            ethDeposit = await maxSubmissionPrice.add(gasPriceBid.mul(maxGas));
        }
        return this.l1Bridge.deposit(erc20L1Address, amount, maxSubmissionPrice, maxGas, gasPriceBid, destinationAddress, Object.assign(Object.assign({}, overrides), { value: ethDeposit }));
    }
    getAndUpdateL1TokenData(erc20l1Address) {
        return this.l1Bridge.getAndUpdateL1TokenData(erc20l1Address);
    }
    async getAndUpdateL2TokenData(erc20l1Address) {
        const l2TokenAddress = await this.l1Bridge.getERC20L2Address(erc20l1Address);
        return this.l2Bridge.getAndUpdateL2TokenData(erc20l1Address, l2TokenAddress);
    }
    async getL1EthBalance() {
        return this.l1Bridge.getL1EthBalance();
    }
    async getL2EthBalance() {
        return this.l2Bridge.getL2EthBalance();
    }
    getL2Transaction(l2TransactionHash) {
        return bridge_helpers_1.BridgeHelper.getL2Transaction(l2TransactionHash, this.l2Provider);
    }
    getL1Transaction(l1TransactionHash) {
        return bridge_helpers_1.BridgeHelper.getL1Transaction(l1TransactionHash, this.l1Provider);
    }
    /**
     * get hash of regular L2 txn from corresponding inbox sequence number
     */
    calculateL2TransactionHash(inboxSequenceNumber, l2ChainId) {
        return bridge_helpers_1.BridgeHelper.calculateL2TransactionHash(inboxSequenceNumber, l2ChainId || this.l2Provider);
    }
    /**
     * Hash of L2 side of retryable txn; txn gets generated automatically and is formatted as tho user submitted
     */
    calculateL2RetryableTransactionHash(inboxSequenceNumber, l2ChainId) {
        return bridge_helpers_1.BridgeHelper.calculateL2RetryableTransactionHash(inboxSequenceNumber, l2ChainId || this.l2Provider);
    }
    /**
     * Hash of L2 ArbOs generated "auto-redeem" transaction; if it succeeded, a transaction queryable by {@link calculateL2RetryableTransactionHash} will then be created
     */
    calculateRetryableAutoRedeemTxnHash(inboxSequenceNumber, l2ChainId) {
        return bridge_helpers_1.BridgeHelper.calculateRetryableAutoRedeemTxnHash(inboxSequenceNumber, l2ChainId || this.l2Provider);
    }
    async getInboxSeqNumFromContractTransaction(l1Transaction) {
        return bridge_helpers_1.BridgeHelper.getInboxSeqNumFromContractTransaction(l1Transaction, 
        // TODO: we don't need to actually make this query if random address fetches interface
        (await this.l1Bridge.getInbox()).address);
    }
    /**
     * Convenience method to directly retrieve retryable hash from an l1 transaction
     */
    async getL2TxHashByRetryableTicket(l1Transaction) {
        if (typeof l1Transaction == 'string') {
            l1Transaction = await this.getL1Transaction(l1Transaction);
        }
        const inboxSeqNum = await this.getInboxSeqNumFromContractTransaction(l1Transaction);
        if (!inboxSeqNum)
            throw new Error('Inbox not triggered');
        return this.calculateL2RetryableTransactionHash(inboxSeqNum[0]);
    }
    async redeemRetryableTicket(l1Transaction, waitTimeForL2Receipt = 900000, // 15 minutes
    overrides) {
        if (typeof l1Transaction == 'string') {
            l1Transaction = await this.getL1Transaction(l1Transaction);
        }
        const inboxSeqNum = await this.getInboxSeqNumFromContractTransaction(l1Transaction);
        if (!inboxSeqNum)
            throw new Error('Inbox not triggered');
        const l2TxnHash = await this.calculateL2TransactionHash(inboxSeqNum[0]);
        console.log('waiting for retryable ticket...', l2TxnHash);
        const l2Txn = await this.l2Provider.waitForTransaction(l2TxnHash, undefined, waitTimeForL2Receipt);
        if (!l2Txn)
            throw new Error('retryable ticket not found');
        console.log('retryable ticket found!');
        if (l2Txn.status === 0) {
            console.warn('retryable ticket failed', l2Txn);
            throw new Error('l2 txn failed');
        }
        const retryHash = await bridge_helpers_1.BridgeHelper.calculateL2RetryableTransactionHash(inboxSeqNum[0], this.l2Provider);
        console.log('Redeeming retryable ticket:', retryHash);
        return this.l2Bridge.arbRetryableTx.redeem(retryHash);
    }
    async cancelRetryableTicket(l1Transaction, waitTimeForL2Receipt = 900000, // 15 minutes
    overrides) {
        if (typeof l1Transaction == 'string') {
            l1Transaction = await this.getL1Transaction(l1Transaction);
        }
        const inboxSeqNum = await this.getInboxSeqNumFromContractTransaction(l1Transaction);
        if (!inboxSeqNum)
            throw new Error('Inbox not triggered');
        const l2TxnHash = await this.calculateL2TransactionHash(inboxSeqNum[0]);
        console.log('waiting for retryable ticket...', l2TxnHash);
        const l2Txn = await this.l2Provider.waitForTransaction(l2TxnHash, undefined, waitTimeForL2Receipt);
        if (!l2Txn)
            throw new Error('retryable ticket not found');
        console.log('retryable ticket found!');
        if (l2Txn.status === 0) {
            console.warn('retryable ticket failed', l2Txn);
            throw new Error('l2 txn failed');
        }
        const redemptionTxHash = await bridge_helpers_1.BridgeHelper.calculateL2RetryableTransactionHash(inboxSeqNum[0], this.l2Provider);
        console.log(`Ensuring txn hasn't been redeemed:`);
        const redemptionRec = await this.l2Provider.getTransactionReceipt(redemptionTxHash);
        if (redemptionRec && redemptionRec.status === 1) {
            throw new Error(`Can't cancel retryable, it's already been redeemed: ${redemptionTxHash}`);
        }
        console.log(`Hasn't been redeemed yet, calling cancel now`);
        return this.l2Bridge.arbRetryableTx.cancel(redemptionTxHash);
    }
    getBuddyDeployInL2Transaction(l2Transaction) {
        return bridge_helpers_1.BridgeHelper.getBuddyDeployInL2Transaction(l2Transaction);
    }
    getWithdrawalsInL2Transaction(l2Transaction) {
        return bridge_helpers_1.BridgeHelper.getWithdrawalsInL2Transaction(l2Transaction, this.l2Provider);
    }
    async getDepositTokenEventData(l1Transaction) {
        const defaultGatewayAddress = (await this.l1Bridge.getDefaultL1Gateway())
            .address;
        return bridge_helpers_1.BridgeHelper.getDepositTokenEventData(l1Transaction, defaultGatewayAddress);
    }
    /**
     * Attempt to execute an outbox message; must be confirmed to succeed (i.e., confirmation delay must have passed)
     */
    async triggerL2ToL1Transaction(batchNumber, indexInBatch, singleAttempt = false) {
        const outboxAddress = await this.getOutboxAddressByBatchNum(batchNumber);
        return bridge_helpers_1.BridgeHelper.triggerL2ToL1Transaction(batchNumber, indexInBatch, outboxAddress, this.l2Provider, this.l1Signer, singleAttempt);
    }
    tryOutboxExecute(outboxAddress, batchNumber, proof, path, l2Sender, l1Dest, l2Block, l1Block, timestamp, amount, calldataForL1) {
        return bridge_helpers_1.BridgeHelper.tryOutboxExecute({
            batchNumber,
            proof,
            path,
            l2Sender,
            l1Dest,
            l2Block,
            l1Block,
            timestamp,
            amount,
            calldataForL1,
        }, outboxAddress, this.l1Signer);
    }
    tryGetProofOnce(batchNumber, indexInBatch) {
        return bridge_helpers_1.BridgeHelper.tryGetProofOnce(batchNumber, indexInBatch, this.l2Provider);
    }
    tryGetProof(batchNumber, indexInBatch, retryDelay = 500) {
        return bridge_helpers_1.BridgeHelper.tryGetProof(batchNumber, indexInBatch, this.l2Provider, retryDelay);
    }
    waitUntilOutboxEntryCreated(batchNumber, outboxAddress) {
        return bridge_helpers_1.BridgeHelper.waitUntilOutboxEntryCreated(batchNumber, outboxAddress, this.l1Provider);
    }
    /**
     * Return receipt of retryable transaction after execution
     */
    async waitForRetryableReceipt(seqNum) {
        return bridge_helpers_1.BridgeHelper.waitForRetryableReceipt(seqNum, this.l2Provider);
    }
    /**
     * All withdrawals from given token
     */
    async getTokenWithdrawEventData(l1TokenAddress, fromAddress, filter) {
        const gatewayAddress = await this.l2Bridge.l2GatewayRouter.getGateway(l1TokenAddress);
        return bridge_helpers_1.BridgeHelper.getTokenWithdrawEventData(this.l2Provider, gatewayAddress, l1TokenAddress, fromAddress, filter);
    }
    /**
     * All withdrawals from given gateway
     */
    async getGatewayWithdrawEventData(gatewayAddress, fromAddress, filter) {
        return bridge_helpers_1.BridgeHelper.getGatewayWithdrawEventData(this.l2Provider, gatewayAddress, fromAddress, filter);
    }
    async getL2ToL1EventData(fromAddress, filter) {
        return bridge_helpers_1.BridgeHelper.getL2ToL1EventData(fromAddress, this.l2Provider, filter);
    }
    async getOutboxAddressByBatchNum(batchNum) {
        const inbox = Inbox__factory_1.Inbox__factory.connect((await this.l1Bridge.getInbox()).address, this.l1Provider);
        const bridge = await Bridge__factory_1.Bridge__factory.connect(await inbox.bridge(), this.l1Provider);
        const oldOutboxAddress = await bridge.allowedOutboxList(0);
        let newOutboxAddress;
        try {
            newOutboxAddress = await bridge.allowedOutboxList(1);
        }
        catch (_a) {
            // new outbox not yet deployed; using old outbox
            return oldOutboxAddress;
        }
        const oldOutbox = OldOutbox__factory_1.OldOutbox__factory.connect(oldOutboxAddress, this.l1Provider);
        const lastOldOutboxBatchNumber = await oldOutbox.outboxesLength();
        return batchNum.lt(lastOldOutboxBatchNumber)
            ? oldOutboxAddress
            : newOutboxAddress;
    }
    /**
     * Returns {@link OutgoingMessageState} for given outgoing message
     */
    async getOutGoingMessageState(batchNumber, indexInBatch) {
        const outboxAddress = await this.getOutboxAddressByBatchNum(batchNumber);
        return bridge_helpers_1.BridgeHelper.getOutGoingMessageState(batchNumber, indexInBatch, outboxAddress, this.l1Provider, this.l2Provider);
    }
    async getERC20L2Address(erc20L1Address) {
        return this.l1Bridge.getERC20L2Address(erc20L1Address);
    }
    async withdrawETH(value, destinationAddress, overrides) {
        return this.l2Bridge.withdrawETH(value, destinationAddress, overrides);
    }
    async withdrawERC20(erc20l1Address, amount, destinationAddress, overrides = {}) {
        return this.l2Bridge.withdrawERC20(erc20l1Address, amount, destinationAddress, overrides);
    }
    isWhiteListed(address, whiteListAddress) {
        return bridge_helpers_1.BridgeHelper.isWhiteListed(address, whiteListAddress, this.l1Provider);
    }
    async setGateways(tokenAddresses, gatewayAddresses) {
        const gasPriceBid = await this.l2Provider.getGasPrice();
        const maxSubmissionPrice = (await this.l2Bridge.getTxnSubmissionPrice(
        // 20 per address, 100 as buffer/ estimate for any additional calldata
        300 + 20 * (tokenAddresses.length + gatewayAddresses.length)))[0];
        return this.l1GatewayRouter.functions.setGateways(tokenAddresses, gatewayAddresses, 0, gasPriceBid, maxSubmissionPrice, {
            value: maxSubmissionPrice,
        });
    }
    async getL1GatewaySetEventData(_l1GatewayRouterAddress) {
        if (this.isCustomNetwork && !_l1GatewayRouterAddress)
            throw new Error('Must supply _l1GatewayRouterAddress for custom network ');
        const l1ChainId = await this.l1Signer.getChainId();
        const l1GatewayRouterAddress = _l1GatewayRouterAddress || networks_1.default[l1ChainId].tokenBridge.l1GatewayRouter;
        if (!l1GatewayRouterAddress)
            throw new Error('No l2GatewayRouterAddress provided');
        return bridge_helpers_1.BridgeHelper.getGatewaySetEventData(l1GatewayRouterAddress, this.l1Provider);
    }
    async getL2GatewaySetEventData(_l2GatewayRouterAddress) {
        if (this.isCustomNetwork && !_l2GatewayRouterAddress)
            throw new Error('Must supply _l2GatewayRouterAddress for custom network ');
        const l1ChainId = await this.l1Signer.getChainId();
        const l2GatewayRouterAddress = _l2GatewayRouterAddress || networks_1.default[l1ChainId].tokenBridge.l2GatewayRouter;
        if (!l2GatewayRouterAddress)
            throw new Error('No l2GatewayRouterAddress provided');
        return bridge_helpers_1.BridgeHelper.getGatewaySetEventData(l2GatewayRouterAddress, this.l2Provider);
    }
}
exports.Bridge = Bridge;
