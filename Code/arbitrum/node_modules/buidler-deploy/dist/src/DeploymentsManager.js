"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const plugins_1 = require("@nomiclabs/buidler/plugins");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const bignumber_1 = require("@ethersproject/bignumber");
const transactions_1 = require("@ethersproject/transactions");
const debug_1 = __importDefault(require("debug"));
const log = debug_1.default("buidler:wighawag:buidler-deploy");
const utils_1 = require("./utils");
const helpers_1 = require("./helpers");
class DeploymentsManager {
    constructor(env) {
        log("constructing DeploymentsManager");
        this.db = {
            accountsLoaded: false,
            namedAccounts: {},
            deploymentsLoaded: false,
            deployments: {},
            migrations: {},
            writeDeploymentsToFiles: false,
            fixtureCounter: 0,
            snapshotCounter: 0,
            pastFixtures: {},
            logEnabled: false,
            pendingTransactions: {},
            savePendingTx: false,
            gasPrice: undefined
        };
        this.env = env;
        this.deploymentsPath =
            env.config.paths.deployments ||
                path_1.default.join(env.config.paths.root, "/deployments");
        this.env.getChainId = () => {
            return utils_1.getChainId(this.env);
        };
        const partialExtension = {
            save: async (name, deployment) => this.saveDeployment(name, deployment),
            get: async (name) => {
                if (!this.db.deploymentsLoaded) {
                    await this.loadDeployments();
                }
                const deployment = this.db.deployments[name];
                if (deployment === undefined) {
                    throw new Error(`No deployment found for: ${name}`);
                }
                return deployment;
            },
            getOrNull: async (name) => {
                if (!this.db.deploymentsLoaded) {
                    await this.loadDeployments();
                }
                return this.db.deployments[name];
            },
            all: async () => {
                if (!this.db.deploymentsLoaded) {
                    await this.loadDeployments();
                }
                return this.db.deployments; // TODO copy
            },
            getArtifact: async (contractName) => {
                let artifact;
                try {
                    artifact = await plugins_1.readArtifact(this.env.config.paths.artifacts, contractName);
                }
                catch (e) {
                    try {
                        artifact = await plugins_1.readArtifact(this.env.config.paths.imports ||
                            path_1.default.join(this.env.config.paths.root, "imports"), contractName);
                    }
                    catch (ee) {
                        throw e;
                    }
                }
                return artifact;
            },
            getArtifactSync: (contractName) => {
                let artifact;
                try {
                    artifact = plugins_1.readArtifactSync(this.env.config.paths.artifacts, contractName);
                }
                catch (e) {
                    try {
                        artifact = plugins_1.readArtifactSync(this.env.config.paths.imports ||
                            path_1.default.join(this.env.config.paths.root, "imports"), contractName);
                    }
                    catch (ee) {
                        throw e;
                    }
                }
                return artifact;
            },
            run: (tags, options = {
                resetMemory: true,
                writeDeploymentsToFiles: false,
                deletePreviousDeployments: false
            }) => {
                return this.runDeploy(tags, {
                    resetMemory: options.resetMemory === undefined ? true : options.resetMemory,
                    deletePreviousDeployments: options.deletePreviousDeployments === undefined
                        ? false
                        : options.deletePreviousDeployments,
                    writeDeploymentsToFiles: options.writeDeploymentsToFiles === undefined
                        ? false
                        : options.writeDeploymentsToFiles,
                    export: options.export,
                    exportAll: options.exportAll,
                    log: false,
                    savePendingTx: false
                });
            },
            fixture: async (tags) => {
                if (typeof tags === "string") {
                    tags = [tags];
                }
                const globalKey = "::global";
                let fixtureKey;
                if (tags !== undefined) {
                    fixtureKey = "::" + tags.join(".");
                }
                const global = this.db.pastFixtures[globalKey];
                if (global) {
                    await this.revertSnapshot(globalKey, global);
                    return this.db.deployments;
                }
                else if (tags !== undefined &&
                    fixtureKey !== undefined &&
                    this.db.pastFixtures[fixtureKey]) {
                    const pastFixture = this.db.pastFixtures[fixtureKey];
                    await this.revertSnapshot(fixtureKey, pastFixture);
                    return this.db.deployments;
                }
                await this.runDeploy(tags, {
                    resetMemory: true,
                    writeDeploymentsToFiles: false,
                    deletePreviousDeployments: false,
                    log: false,
                    savePendingTx: false
                });
                if (fixtureKey !== undefined) {
                    await this.saveSnapshot(fixtureKey);
                }
                else {
                    await this.saveSnapshot(globalKey);
                }
                return this.db.deployments;
            },
            createFixture: (func) => {
                const baseId = "" + ++this.db.fixtureCounter + "::";
                return async (options) => {
                    let id = baseId;
                    if (options !== undefined) {
                        id = id + JSON.stringify(options);
                    }
                    const saved = this.db.pastFixtures[id];
                    if (saved) {
                        await this.revertSnapshot(id, saved);
                        return saved.data;
                    }
                    const data = await func(this.env, options);
                    await this.saveSnapshot(id, data);
                    return data;
                };
            },
            log: (...args) => {
                if (this.db.logEnabled) {
                    console.log(...args);
                }
            }
        };
        const print = (msg) => {
            if (this.db.logEnabled) {
                process.stdout.write(msg);
            }
        };
        log("adding helpers");
        this.deploymentsExtension = helpers_1.addHelpers(env, partialExtension, partialExtension.getArtifact, this.onPendingTx.bind(this), async () => {
            // TODO extraGasPrice ?
            if (this.db.gasPrice) {
                return bignumber_1.BigNumber.from(this.db.gasPrice);
            }
            else {
                return undefined;
            }
        }, partialExtension.log, print);
    }
    async dealWithPendingTransactions() {
        let pendingTxs = {};
        const chainId = await utils_1.getChainId(this.env);
        const pendingTxPath = path_1.default.join(this.deploymentsPath, this.getDeploymentsSubPath(chainId), ".pendingTransactions");
        try {
            pendingTxs = JSON.parse(fs_extra_1.default.readFileSync(pendingTxPath).toString());
        }
        catch (e) { }
        const txHashes = Object.keys(pendingTxs);
        for (const txHash of txHashes) {
            const txData = pendingTxs[txHash];
            if (txData.rawTx || txData.decoded) {
                let tx;
                if (txData.rawTx) {
                    tx = transactions_1.parse(txData.rawTx);
                }
                else {
                    function recode(decoded) {
                        return {
                            from: decoded.from,
                            gasPrice: bignumber_1.BigNumber.from(decoded.from),
                            gasLimit: bignumber_1.BigNumber.from(decoded.gasLimit),
                            to: decoded.to,
                            value: bignumber_1.BigNumber.from(decoded.value),
                            nonce: decoded.nonce,
                            data: decoded.data,
                            r: decoded.r,
                            s: decoded.s,
                            v: decoded.v,
                            // creates: tx.creates, // TODO test
                            chainId: decoded.chainId
                        };
                    }
                    tx = recode(txData.decoded);
                }
                if (this.db.gasPrice) {
                    if (tx.gasPrice.lt(this.db.gasPrice)) {
                        // TODO
                        console.log("TODO : resubmit tx with higher gas price");
                        console.log(tx);
                    }
                }
                // alternative add options to deploy task to delete pending tx, combined with --gasprice this would work (except for timing edge case)
            }
            else {
                console.error(`no access to raw data for tx ${txHash}`);
            }
            if (this.db.logEnabled) {
                console.log(`waiting for tx ${txHash}` +
                    (txData.name ? ` for ${txData.name} Deployment` : ""));
            }
            const receipt = await helpers_1.waitForTx(this.env.ethereum, txHash, false);
            if (receipt.contractAddress && txData.name) {
                await this.saveDeployment(txData.name, Object.assign(Object.assign({}, txData.deployment), { receipt }));
            }
            delete pendingTxs[txHash];
            if (Object.keys(pendingTxs).length === 0) {
                fs_extra_1.default.removeSync(pendingTxPath);
            }
            else {
                fs_extra_1.default.writeFileSync(pendingTxPath, JSON.stringify(pendingTxs, null, "  "));
            }
        }
    }
    async onPendingTx(tx, name, deployment) {
        if (this.db.writeDeploymentsToFiles && this.db.savePendingTx) {
            const chainId = await utils_1.getChainId(this.env);
            const deployFolderPath = path_1.default.join(this.deploymentsPath, this.getDeploymentsSubPath(chainId));
            // console.log("tx", tx.hash);
            const pendingTxPath = path_1.default.join(deployFolderPath, ".pendingTransactions");
            fs_extra_1.default.ensureDirSync(deployFolderPath);
            const rawTx = tx.raw;
            const decoded = tx.raw
                ? undefined
                : {
                    from: tx.from,
                    gasPrice: tx.from.toString(),
                    gasLimit: tx.gasLimit.toString(),
                    to: tx.to,
                    value: tx.value.toString(),
                    nonce: tx.nonce,
                    data: tx.data,
                    r: tx.r,
                    s: tx.s,
                    v: tx.v,
                    // creates: tx.creates, // TODO test
                    chainId: tx.chainId
                };
            this.db.pendingTransactions[tx.hash] = name
                ? { name, deployment, rawTx, decoded }
                : { rawTx, decoded };
            fs_extra_1.default.writeFileSync(pendingTxPath, JSON.stringify(this.db.pendingTransactions, null, "  "));
            // await new Promise(r => setTimeout(r, 20000));
            const wait = tx.wait.bind(tx);
            tx.wait = async () => {
                const receipt = await wait();
                // console.log("checking pending tx...");
                delete this.db.pendingTransactions[tx.hash];
                if (Object.keys(this.db.pendingTransactions).length === 0) {
                    fs_extra_1.default.removeSync(pendingTxPath);
                }
                else {
                    fs_extra_1.default.writeFileSync(pendingTxPath, JSON.stringify(this.db.pendingTransactions, null, "  "));
                }
                return receipt;
            };
        }
        return tx;
    }
    async getNamedAccounts() {
        if (!this.db.accountsLoaded) {
            const chainId = await utils_1.getChainId(this.env);
            const accounts = await this.env.ethereum.send("eth_accounts");
            this.db.namedAccounts = utils_1.processNamedAccounts(this.env, accounts, chainId);
            this.db.accountsLoaded = true;
        }
        return this.db.namedAccounts;
    }
    async loadDeployments() {
        const chainId = await utils_1.getChainId(this.env);
        // this.env.deployments.chainId = chainId;
        const folderPath = this.getDeploymentsSubPath(chainId);
        let migrations = {};
        try {
            log("loading migrations");
            migrations = JSON.parse(fs_extra_1.default
                .readFileSync(path_1.default.join(this.deploymentsPath, folderPath, ".migrations.json"))
                .toString());
        }
        catch (e) { }
        this.db.migrations = migrations;
        // console.log({ migrations: this.db.migrations });
        utils_1.addDeployments(this.db, this.deploymentsPath, folderPath);
        this.db.deploymentsLoaded = true;
        return this.db.deployments;
    }
    async deletePreviousDeployments() {
        const chainId = await utils_1.getChainId(this.env);
        const folderPath = this.getDeploymentsSubPath(chainId);
        try {
            fs_extra_1.default.removeSync(path_1.default.join(this.deploymentsPath, folderPath, ".migrations.json"));
        }
        catch (e) { }
        utils_1.deleteDeployments(this.deploymentsPath, folderPath);
    }
    async getSolcInputPath() {
        const chainId = await utils_1.getChainId(this.env);
        return path_1.default.join(this.deploymentsPath, this.getDeploymentsSubPath(chainId), "solcInputs");
    }
    async saveDeployment(name, deployment) {
        var _a;
        if (typeof deployment.receipt === undefined) {
            throw new Error("deployment need a receipt");
        }
        if (typeof deployment.address === undefined &&
            typeof deployment.receipt.contractAddress === undefined) {
            throw new Error("deployment need a receipt with contractAddress or an address");
        }
        if (typeof deployment.abi === undefined) {
            throw new Error("deployment need an ABI");
        }
        const chainId = await utils_1.getChainId(this.env);
        const toSave = this.db.writeDeploymentsToFiles && this.env.network.saveDeployments;
        const filepath = path_1.default.join(this.deploymentsPath, this.getDeploymentsSubPath(chainId), name + ".json");
        // handle ethers receipt :
        const receipt = deployment.receipt;
        const actualReceipt = {
            to: receipt.to,
            from: receipt.from,
            contractAddress: receipt.contractAddress,
            transactionIndex: receipt.transactionIndex,
            gasUsed: receipt.gasUsed && receipt.gasUsed._isBigNumber
                ? receipt.gasUsed.toString()
                : receipt.gasUsed,
            logsBloom: receipt.logsBloom,
            blockHash: receipt.blockHash,
            transactionHash: receipt.transactionHash,
            logs: receipt.logs,
            events: receipt.events,
            blockNumber: receipt.blockNumber,
            cumulativeGasUsed: receipt.cumulativeGasUsed && receipt.cumulativeGasUsed._isBigNumber
                ? receipt.cumulativeGasUsed.toString()
                : receipt.cumulativeGasUsed,
            status: receipt.status,
            byzantium: receipt.byzantium
        };
        // from : https://stackoverflow.com/a/14810722/1663971
        function objectMap(object, mapFn) {
            return Object.keys(object).reduce(function (result, key) {
                result[key] = mapFn(object[key]);
                return result;
            }, {});
        }
        // TODO can cause infinite loop
        function transform(v) {
            if (v._isBigNumber) {
                return v.toString();
            }
            if (Array.isArray(v)) {
                return v.map(transform);
            }
            if (typeof v === "object") {
                return objectMap(v, transform);
            }
            return v;
        }
        const actualArgs = (_a = deployment.args) === null || _a === void 0 ? void 0 : _a.map(transform);
        const obj = JSON.parse(JSON.stringify({
            abi: deployment.abi,
            receipt: actualReceipt,
            address: deployment.address || actualReceipt.contractAddress,
            args: actualArgs,
            linkedData: deployment.linkedData,
            solcInputHash: deployment.solcInputHash,
            metadata: deployment.metadata,
            bytecode: deployment.bytecode,
            deployedBytecode: deployment.deployedBytecode,
            libraries: deployment.libraries,
            facets: deployment.facets,
            diamondCuts: deployment.diamondCuts,
            execute: deployment.execute,
            history: deployment.history,
            devdoc: deployment.devdoc,
            userdoc: deployment.userdoc,
            storageLayout: deployment.storageLayout,
            methodIdentifiers: deployment.methodIdentifiers,
            gasEstimates: deployment.gasEstimates
        }));
        this.db.deployments[name] = obj;
        if (obj.address === undefined && obj.transactionHash !== undefined) {
            let receiptFetched;
            try {
                receiptFetched = await helpers_1.waitForTx(this.env.ethereum, obj.transactionHash, true);
                obj.address = receiptFetched.contractAddress;
                if (!obj.address) {
                    throw new Error("no contractAddress in receipt");
                }
            }
            catch (e) {
                console.error(e);
                if (toSave) {
                    console.log("deleting " + filepath);
                    fs_extra_1.default.unlinkSync(filepath);
                }
                delete this.db.deployments[name];
                return false; // TODO throw error ?
            }
        }
        this.db.deployments[name] = obj;
        // console.log({chainId, typeOfChainId: typeof chainId});
        if (toSave) {
            // console.log("writing " + filepath); // TODO remove
            try {
                fs_extra_1.default.mkdirSync(this.deploymentsPath);
            }
            catch (e) { }
            try {
                fs_extra_1.default.mkdirSync(path_1.default.join(this.deploymentsPath, this.getDeploymentsSubPath(chainId)));
            }
            catch (e) { }
            fs_extra_1.default.writeFileSync(filepath, JSON.stringify(obj, null, "  "));
            if (deployment.solcInputHash) {
                const solcInputsFolderpath = path_1.default.join(this.deploymentsPath, this.getDeploymentsSubPath(chainId), "solcInputs");
                const solcInputFilepath = path_1.default.join(solcInputsFolderpath, deployment.solcInputHash + ".json");
                if (!fs_extra_1.default.existsSync(solcInputFilepath)) {
                    try {
                        fs_extra_1.default.mkdirSync(solcInputsFolderpath);
                    }
                    catch (e) { }
                    fs_extra_1.default.writeFileSync(solcInputFilepath, deployment.solcInput);
                }
            }
        }
        // this.spreadEvents();
        return true;
    }
    async runDeploy(tags, options = {
        log: false,
        resetMemory: true,
        deletePreviousDeployments: false,
        writeDeploymentsToFiles: true,
        savePendingTx: false
    }) {
        log("runDeploy");
        const chainId = await utils_1.getChainId(this.env);
        await this.loadDeployments();
        const deploymentFolderPath = this.getDeploymentsSubPath(chainId);
        const wasWrittingToFiles = this.db.writeDeploymentsToFiles;
        this.db.writeDeploymentsToFiles = options.writeDeploymentsToFiles;
        this.db.savePendingTx = options.savePendingTx;
        this.db.logEnabled = options.log;
        this.db.gasPrice = options.gasPrice;
        if (options.resetMemory) {
            log("reseting memory");
            this.db.deployments = {};
            this.db.migrations = {};
        }
        if (options.deletePreviousDeployments) {
            log("deleting previous deployments");
            this.db.deployments = {};
            this.db.migrations = {};
            await this.deletePreviousDeployments();
        }
        else {
            if (options.savePendingTx) {
                await this.dealWithPendingTransactions(); // TODO deal with reset ?
            }
        }
        if (tags !== undefined && typeof tags === "string") {
            tags = [tags];
        }
        const deployPath = this.env.config.paths.deploy ||
            path_1.default.join(this.env.config.paths.root, "/deploy"); // TODO extendConfig ?
        let filesStats;
        try {
            filesStats = utils_1.traverse(deployPath);
        }
        catch (e) {
            // console.log('no folder at ' + deployPath);
            return {};
        }
        let fileNames = filesStats.map((a) => a.relativePath);
        fileNames = fileNames.sort((a, b) => {
            if (a < b) {
                return -1;
            }
            if (a > b) {
                return 1;
            }
            return 0;
        });
        log("deploy script folder parsed");
        const funcByFilePath = {};
        const scriptPathBags = {};
        const scriptFilePaths = [];
        for (const filename of fileNames) {
            const scriptFilePath = path_1.default.join(deployPath, filename);
            let deployFunc;
            // console.log("fetching " + scriptFilePath);
            try {
                // TODO when watch is enabled : delete require.cache[path.resolve(scriptFilePath)]; // ensure we reload it every time, so changes are taken in consideration
                deployFunc = require(scriptFilePath);
                if (deployFunc.default) {
                    deployFunc = deployFunc.default;
                }
                funcByFilePath[scriptFilePath] = deployFunc;
            }
            catch (e) {
                // console.error("require failed", e);
                throw new Error("ERROR processing skip func of " +
                    scriptFilePath +
                    ":\n" +
                    (e.stack || e));
            }
            // console.log("get tags if any for " + scriptFilePath);
            let scriptTags = deployFunc.tags;
            if (scriptTags !== undefined) {
                if (typeof scriptTags === "string") {
                    scriptTags = [scriptTags];
                }
                for (const tag of scriptTags) {
                    const bag = scriptPathBags[tag] || [];
                    scriptPathBags[tag] = bag;
                    bag.push(scriptFilePath);
                }
            }
            // console.log("tags found " + scriptFilePath, scriptTags);
            if (tags !== undefined) {
                let found = false;
                if (scriptTags !== undefined) {
                    for (const tagToFind of tags) {
                        for (const tag of scriptTags) {
                            if (tag === tagToFind) {
                                scriptFilePaths.push(scriptFilePath);
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            break;
                        }
                    }
                }
            }
            else {
                scriptFilePaths.push(scriptFilePath);
            }
        }
        log("tag collected");
        // console.log({ scriptFilePaths });
        const scriptsRegisteredToRun = {};
        const scriptsToRun = [];
        const scriptsToRunAtTheEnd = [];
        function recurseDependencies(scriptFilePath) {
            if (scriptsRegisteredToRun[scriptFilePath]) {
                return;
            }
            const deployFunc = funcByFilePath[scriptFilePath];
            if (deployFunc.dependencies) {
                for (const dependency of deployFunc.dependencies) {
                    const scriptFilePathsToAdd = scriptPathBags[dependency];
                    if (scriptFilePathsToAdd) {
                        for (const scriptFilenameToAdd of scriptFilePathsToAdd) {
                            recurseDependencies(scriptFilenameToAdd);
                        }
                    }
                }
            }
            if (!scriptsRegisteredToRun[scriptFilePath]) {
                if (deployFunc.runAtTheEnd) {
                    scriptsToRunAtTheEnd.push({
                        filePath: scriptFilePath,
                        func: deployFunc
                    });
                }
                else {
                    scriptsToRun.push({
                        filePath: scriptFilePath,
                        func: deployFunc
                    });
                }
                scriptsRegisteredToRun[scriptFilePath] = true;
            }
        }
        for (const scriptFilePath of scriptFilePaths) {
            recurseDependencies(scriptFilePath);
        }
        log("dependencies collected");
        try {
            for (const deployScript of scriptsToRun.concat(scriptsToRunAtTheEnd)) {
                const filename = path_1.default.basename(deployScript.filePath);
                if (this.db.migrations[filename]) {
                    log(`skipping ${filename} as migrations already executed and complete`);
                    continue;
                }
                let skip = false;
                if (deployScript.func.skip) {
                    log(`should we skip  ${deployScript.filePath} ?`);
                    try {
                        skip = await deployScript.func.skip(this.env);
                    }
                    catch (e) {
                        // console.error("skip failed", e);
                        throw new Error("ERROR processing skip func of " +
                            deployScript.filePath +
                            ":\n" +
                            (e.stack || e));
                    }
                    log(`checking skip for ${deployScript.filePath} complete`);
                }
                if (!skip) {
                    log(`executing  ${deployScript.filePath}`);
                    let result;
                    try {
                        result = await deployScript.func(this.env);
                    }
                    catch (e) {
                        // console.error("execution failed", e);
                        throw new Error("ERROR processing " +
                            deployScript.filePath +
                            ":\n" +
                            (e.stack || e));
                    }
                    log(`executing ${deployScript.filePath} complete`);
                    if (result && typeof result === "boolean") {
                        this.db.migrations[filename] = Math.floor(Date.now() / 1000);
                        // TODO refactor to extract this whole path and folder existence stuff
                        const toSave = this.db.writeDeploymentsToFiles &&
                            this.env.network.saveDeployments;
                        if (toSave) {
                            try {
                                fs_extra_1.default.mkdirSync(this.deploymentsPath);
                            }
                            catch (e) { }
                            try {
                                fs_extra_1.default.mkdirSync(path_1.default.join(this.deploymentsPath, deploymentFolderPath));
                            }
                            catch (e) { }
                            fs_extra_1.default.writeFileSync(path_1.default.join(this.deploymentsPath, deploymentFolderPath, ".migrations.json"), JSON.stringify(this.db.migrations, null, "  "));
                        }
                    }
                }
            }
        }
        catch (e) {
            this.db.writeDeploymentsToFiles = wasWrittingToFiles;
            throw e;
        }
        this.db.writeDeploymentsToFiles = wasWrittingToFiles;
        log("deploy scripts complete");
        if (options.exportAll !== undefined) {
            log("load all deployments for export-all");
            const all = utils_1.loadAllDeployments(this.deploymentsPath, true);
            const currentNetworkDeployments = {};
            const currentDeployments = this.db.deployments;
            for (const contractName of Object.keys(currentDeployments)) {
                const deployment = currentDeployments[contractName];
                currentNetworkDeployments[contractName] = {
                    address: deployment.address,
                    abi: deployment.abi,
                    linkedData: deployment.linkedData
                };
            }
            if (all[chainId] === undefined) {
                all[chainId] = {};
            }
            else {
                // Ensure no past deployments are recorded
                delete all[chainId][this.env.network.name];
            }
            all[chainId][this.env.network.name] = {
                name: this.env.network.name,
                chainId,
                contracts: currentNetworkDeployments
            };
            fs_extra_1.default.writeFileSync(options.exportAll, JSON.stringify(all, null, "  ")); // TODO remove bytecode ?
            log("export-all complete");
        }
        if (options.export !== undefined) {
            log("single export...");
            const currentNetworkDeployments = {};
            if (chainId !== undefined) {
                const currentDeployments = this.db.deployments;
                for (const contractName of Object.keys(currentDeployments)) {
                    const deployment = currentDeployments[contractName];
                    currentNetworkDeployments[contractName] = {
                        address: deployment.address,
                        abi: deployment.abi,
                        linkedData: deployment.linkedData
                    };
                }
            }
            else {
                throw new Error("chainId is undefined");
            }
            const singleExport = {
                name: this.env.network.name,
                chainId,
                contracts: currentNetworkDeployments
            };
            fs_extra_1.default.writeFileSync(options.export, JSON.stringify(singleExport, null, "  ")); // TODO remove bytecode ?
            log("single export complete");
        }
        return this.db.deployments;
    }
    async saveSnapshot(key, data) {
        const snapshot = await this.env.ethereum.send("evm_snapshot", []);
        this.db.pastFixtures[key] = {
            index: ++this.db.snapshotCounter,
            snapshot,
            data,
            deployments: Object.assign({}, this.db.deployments)
        };
    }
    async revertSnapshot(key, saved) {
        const snapshotToRevertIndex = saved.index;
        for (const fixtureKey of Object.keys(this.db.pastFixtures)) {
            const snapshotIndex = this.db.pastFixtures[fixtureKey].index;
            if (snapshotIndex > snapshotToRevertIndex) {
                delete this.db.pastFixtures[fixtureKey];
            }
        }
        await this.env.ethereum.send("evm_revert", [saved.snapshot]);
        saved.snapshot = await this.env.ethereum.send("evm_snapshot", []); // it is necessary to re-snapshot it
        this.db.deployments = Object.assign({}, saved.deployments);
    }
    getDeploymentsSubPath(chainId) {
        const name = this.env.network.name;
        const num = parseInt(name, 10);
        let expectedChainId;
        if (typeof num === "number" && !isNaN(num)) {
            expectedChainId = name;
        }
        else {
            expectedChainId = utils_1.nameToChainId[name];
        }
        if (expectedChainId !== undefined) {
            if (expectedChainId !== bignumber_1.BigNumber.from(chainId).toString()) {
                throw new Error(`Network name ("${name}") is confusing, chainId is ${chainId}. Was expecting ${expectedChainId}`);
            }
            return name;
        }
        return name + "_" + bignumber_1.BigNumber.from(chainId).toString();
    }
}
exports.DeploymentsManager = DeploymentsManager;
//# sourceMappingURL=DeploymentsManager.js.map