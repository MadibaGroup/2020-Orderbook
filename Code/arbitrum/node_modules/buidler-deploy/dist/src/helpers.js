"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const providers_1 = require("@ethersproject/providers");
const contracts_1 = require("@ethersproject/contracts");
const bignumber_1 = require("@ethersproject/bignumber");
const wallet_1 = require("@ethersproject/wallet");
const solidity_1 = require("@ethersproject/solidity");
const bytes_1 = require("@ethersproject/bytes");
const abi_1 = require("@ethersproject/abi");
const TransparentProxy_json_1 = __importDefault(require("../artifacts/TransparentProxy.json"));
const DiamondBase_json_1 = __importDefault(require("../artifacts/DiamondBase.json"));
const DiamondFacet_json_1 = __importDefault(require("../artifacts/DiamondFacet.json"));
const OwnershipFacet_json_1 = __importDefault(require("../artifacts/OwnershipFacet.json"));
const DiamondLoupeFacet_json_1 = __importDefault(require("../artifacts/DiamondLoupeFacet.json"));
const Diamantaire_json_1 = __importDefault(require("../artifacts/Diamantaire.json"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
function mergeABIs(...abis) {
    return _mergeABIs(undefined, ...abis);
}
function mergeAndCheckDiamondAbis(...abis) {
    // TODO remove duplication with builtin facet enumeration
    return _mergeABIs([
        "0x01ffc9a7",
        "0xadfca15e",
        "0x7a0ed627",
        "0xcdffacc6",
        "0x52ef6b2c",
        "0x99f5f52e",
        "0xf2fde38b",
        "0x8da5cb5b"
    ], ...abis);
}
function _mergeABIs(check, ...abis) {
    if (abis.length === 0) {
        return [];
    }
    const result = abis[0];
    for (let i = 1; i < abis.length; i++) {
        const abi = abis[i];
        for (const fragment of abi) {
            const newEthersFragment = abi_1.Fragment.from(fragment);
            if (check) {
                if (newEthersFragment && newEthersFragment.type === "function") {
                    if (check.find(v => v ===
                        abi_1.Interface.getSighash(newEthersFragment))) {
                        throw new Error(`Function ${newEthersFragment.name} will shadow Diamond contract base facets`);
                    }
                }
            }
            // TODO constructor special handling ?
            const foundSameSig = result.find(v => {
                const existingEthersFragment = abi_1.Fragment.from(v);
                if (v.type !== fragment.type) {
                    return false;
                }
                if (!existingEthersFragment) {
                    return v.name === fragment.name; // TODO fallback and receive hanlding
                }
                if (existingEthersFragment.type === "constructor" ||
                    newEthersFragment.type === "constructor") {
                    return existingEthersFragment.name === newEthersFragment.name;
                }
                if (newEthersFragment.type === "function") {
                    return (abi_1.Interface.getSighash(existingEthersFragment) ===
                        abi_1.Interface.getSighash(newEthersFragment));
                }
                else if (newEthersFragment.type === "event") {
                    return existingEthersFragment.format() === newEthersFragment.format();
                }
                else {
                    return v.name === fragment.name; // TODO fallback and receive hanlding
                }
            });
            if (foundSameSig) {
                if (check && fragment.type === "function") {
                    throw new Error(`function "${fragment.name}" will shadow "${foundSameSig.name}". Please update code to avoid conflict.`);
                }
            }
            else {
                result.push(fragment);
            }
        }
    }
    return result;
}
DiamondBase_json_1.default.abi = mergeABIs(DiamondBase_json_1.default.abi, DiamondFacet_json_1.default.abi, DiamondLoupeFacet_json_1.default.abi, OwnershipFacet_json_1.default.abi);
function fixProvider(providerGiven) {
    // alow it to be used by ethers without any change
    if (providerGiven.sendAsync === undefined) {
        providerGiven.sendAsync = (req, callback) => {
            providerGiven
                .send(req.method, req.params)
                .then((result) => callback(null, { result, id: req.id, jsonrpc: req.jsonrpc }))
                .catch((error) => callback(error, null));
        };
    }
    return providerGiven;
}
function linkRawLibrary(bytecode, libraryName, libraryAddress) {
    const address = libraryAddress.replace("0x", "");
    let encodedLibraryName;
    if (libraryName.startsWith("$") && libraryName.endsWith("$")) {
        encodedLibraryName = libraryName.slice(1, libraryName.length - 1);
    }
    else {
        encodedLibraryName = solidity_1.keccak256(["string"], [libraryName]).slice(2, 36);
    }
    const pattern = new RegExp(`_+\\$${encodedLibraryName}\\$_+`, "g");
    if (!pattern.exec(bytecode)) {
        throw new Error(`Can't link '${libraryName}' (${encodedLibraryName}) in \n----\n ${bytecode}\n----\n`);
    }
    return bytecode.replace(pattern, address);
}
function linkRawLibraries(bytecode, libraries) {
    for (const libName of Object.keys(libraries)) {
        const libAddress = libraries[libName];
        bytecode = linkRawLibrary(bytecode, libName, libAddress);
    }
    return bytecode;
}
function linkLibraries(artifact, libraries) {
    let bytecode = artifact.bytecode;
    if (libraries) {
        if (artifact.linkReferences) {
            for (const [fileName, fileReferences] of Object.entries(artifact.linkReferences)) {
                for (const [libName, fixups] of Object.entries(fileReferences)) {
                    const addr = libraries[libName];
                    if (addr === undefined) {
                        continue;
                    }
                    for (const fixup of fixups) {
                        bytecode =
                            bytecode.substr(0, 2 + fixup.start * 2) +
                                addr.substr(2) +
                                bytecode.substr(2 + (fixup.start + fixup.length) * 2);
                    }
                }
            }
        }
        else {
            bytecode = linkRawLibraries(bytecode, libraries);
        }
    }
    // TODO return libraries object with path name <filepath.sol>:<name> for names
    return bytecode;
}
let solcInput;
let solcInputHash;
let solcOutput;
let provider;
const availableAccounts = {};
function addHelpers(env, partialExtension, // TODO
getArtifact, onPendingTx, getGasPrice, log, print) {
    async function init() {
        if (!provider) {
            provider = new providers_1.Web3Provider(fixProvider(env.ethereum));
            try {
                const accounts = await provider.send("eth_accounts", []);
                for (const account of accounts) {
                    availableAccounts[account.toLowerCase()] = true;
                }
            }
            catch (e) { }
            // TODO wait for buidler to have the info in artifact
            try {
                solcOutput = JSON.parse(fs_1.default
                    .readFileSync(path_1.default.join(env.config.paths.cache, "solc-output.json"))
                    .toString());
            }
            catch (e) { }
            // Necessary for etherscan it seems. using metadata seems insuficient to reconstruct the necessary info for etherscan. Here is a diff of a success vs failure case: https://gist.github.com/wighawag/dfc123ffb7838e5aeb88f58abff505f7
            try {
                solcInput = fs_1.default
                    .readFileSync(path_1.default.join(env.config.paths.cache, "solc-input.json"))
                    .toString();
            }
            catch (e) { }
            if (solcInput) {
                solcInputHash = solidity_1.keccak256(["string"], [solcInput]);
            }
        }
    }
    async function setupGasPrice(overrides) {
        if (!overrides.gasPrice) {
            overrides.gasPrice = await getGasPrice();
        }
    }
    async function overrideGasLimit(overrides, options, estimate) {
        const estimatedGasLimit = options.estimatedGasLimit
            ? bignumber_1.BigNumber.from(options.estimatedGasLimit).toNumber()
            : undefined;
        const estimateGasExtra = options.estimateGasExtra
            ? bignumber_1.BigNumber.from(options.estimateGasExtra).toNumber()
            : undefined;
        if (!overrides.gasLimit) {
            overrides.gasLimit = estimatedGasLimit;
            overrides.gasLimit = (await estimate(overrides)).toNumber();
            if (estimateGasExtra) {
                overrides.gasLimit = overrides.gasLimit + estimateGasExtra;
                if (estimatedGasLimit) {
                    overrides.gasLimit = Math.min(overrides.gasLimit, estimatedGasLimit);
                }
            }
        }
    }
    function getCreate2Address(create2DeployerAddress, salt, bytecode) {
        return ("0x" +
            solidity_1.keccak256(["bytes"], [
                `0xff${create2DeployerAddress.slice(2)}${salt.slice(2)}${solidity_1.keccak256(["bytes"], [bytecode]).slice(2)}`
            ]).slice(-40));
    }
    async function getArtifactFromOptions(name, options) {
        let artifact;
        let contractName;
        if (options.contract) {
            if (typeof options.contract === "string") {
                contractName = options.contract;
                artifact = await getArtifact(options.contract);
            }
            else {
                artifact = options.contract;
            }
        }
        else {
            contractName = name;
            artifact = await getArtifact(name);
        }
        return { artifact, contractName };
    }
    async function _deploy(name, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const args = options.args ? [...options.args] : [];
        await init();
        const { address: from, ethersSigner } = getFrom(options.from);
        if (!ethersSigner) {
            throw new Error("no signer for " + from);
        }
        const artifactInfo = await getArtifactFromOptions(name, options);
        const { artifact } = artifactInfo;
        const { contractName } = artifactInfo;
        const abi = artifact.abi;
        const byteCode = linkLibraries(artifact, options.libraries);
        const factory = new contracts_1.ContractFactory(abi, byteCode, ethersSigner);
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice,
            value: options.value,
            nonce: options.nonce
        };
        const unsignedTx = factory.getDeployTransaction(...args, overrides);
        let create2Address;
        if (options.useCreate2) {
            if (typeof unsignedTx.data === "string") {
                const create2Salt = typeof options.useCreate2 === "string"
                    ? bytes_1.hexlify(bytes_1.zeroPad(options.useCreate2, 32))
                    : "0x0000000000000000000000000000000000000000000000000000000000000000";
                const create2DeployerAddress = "0x4e59b44847b379578588920ca78fbf26c0b4956c";
                create2Address = getCreate2Address(create2DeployerAddress, create2Salt, unsignedTx.data);
                const code = await provider.getCode(create2DeployerAddress);
                if (code === "0x") {
                    const senderAddress = "0x3fab184622dc19b6109349b94811493bf2a45362";
                    if (options.log) {
                        log(`sending eth to create 2 contract deployer address (${senderAddress})...`);
                    }
                    await ethersSigner.sendTransaction({
                        to: senderAddress,
                        value: bignumber_1.BigNumber.from("10000000000000000").toHexString()
                    });
                    // await provider.send("eth_sendTransaction", [{
                    //   from
                    // }]);
                    if (options.log) {
                        log(`deploying create2 deployer contract (at ${create2DeployerAddress}) using deterministic deployment (https://github.com/Arachnid/deterministic-deployment-proxy)...`);
                    }
                    await provider.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
                }
                unsignedTx.to = create2DeployerAddress;
                unsignedTx.data = create2Salt + unsignedTx.data.slice(2);
            }
            else {
                throw new Error("unsigned tx data as bytes not supported");
            }
        }
        await overrideGasLimit(unsignedTx, options, newOverrides => ethersSigner.estimateGas(newOverrides));
        await setupGasPrice(unsignedTx);
        let tx = await ethersSigner.sendTransaction(unsignedTx);
        // await overrideGasLimit(overrides, options, newOverrides =>
        //   ethersSigner.estimateGas(newOverrides)
        // );
        // await setupGasPrice(overrides);
        // console.log({ args, overrides });
        // const ethersContract = await factory.deploy(...args, overrides);
        // let tx = ethersContract.deployTransaction;
        if (options.dev_forceMine) {
            try {
                await provider.send("evm_mine", []);
            }
            catch (e) { }
        }
        let contractSolcOutput;
        if (!contractName) {
            if (typeof options.contract === "object") {
                contractSolcOutput = {
                    metadata: (_a = options.contract) === null || _a === void 0 ? void 0 : _a.metadata,
                    methodIdentifiers: (_b = options.contract) === null || _b === void 0 ? void 0 : _b.methodIdentifiers,
                    storageLayout: (_c = options.contract) === null || _c === void 0 ? void 0 : _c.storageLayout,
                    userdoc: (_d = options.contract) === null || _d === void 0 ? void 0 : _d.userdoc,
                    devdoc: (_e = options.contract) === null || _e === void 0 ? void 0 : _e.devdoc,
                    evm: {
                        gasEstimates: (_f = options.contract) === null || _f === void 0 ? void 0 : _f.gasEstimates
                    }
                };
            }
            if (!contractSolcOutput || !contractSolcOutput.metadata) {
                log(`no metadata associated with contract deployed as ${name}`);
            }
        }
        else {
            if (solcOutput) {
                for (const fileEntry of Object.entries(solcOutput.contracts)) {
                    for (const contractEntry of Object.entries(fileEntry[1])) {
                        if (contractEntry[0] === contractName) {
                            if (artifact.bytecode ===
                                "0x" + ((_h = (_g = contractEntry[1].evm) === null || _g === void 0 ? void 0 : _g.bytecode) === null || _h === void 0 ? void 0 : _h.object)) {
                                contractSolcOutput = contractEntry[1];
                            }
                        }
                    }
                }
            }
            else {
                log(`solc-output not found, it is not possible to get the metadata for ${name}`);
            }
        }
        // const extendedAtifact = artifact as any; // TODO future version of buidler will hopefully have that info
        const preDeployment = {
            abi,
            args,
            linkedData: options.linkedData,
            solcInputHash,
            solcInput,
            metadata: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.metadata,
            bytecode: artifact.bytecode,
            deployedBytecode: artifact.deployedBytecode,
            libraries: options.libraries,
            userdoc: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.userdoc,
            devdoc: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.devdoc,
            methodIdentifiers: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.methodIdentifiers,
            storageLayout: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.storageLayout,
            gasEstimates: (_j = contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.evm) === null || _j === void 0 ? void 0 : _j.gasEstimates
        };
        tx = await onPendingTx(tx, name, preDeployment);
        const receipt = await tx.wait();
        const address = options.useCreate2 && create2Address
            ? create2Address
            : receipt.contractAddress;
        const deployment = Object.assign(Object.assign({}, preDeployment), { address,
            receipt });
        await env.deployments.save(name, deployment);
        return Object.assign(Object.assign({}, deployment), { address, newlyDeployed: true });
    }
    async function create2(name, options) {
        // TODO refactor to share that code:
        const args = options.args ? [...options.args] : [];
        await init();
        const { address: from, ethersSigner } = getFrom(options.from);
        if (!ethersSigner) {
            throw new Error("no signer for " + from);
        }
        const artifactInfo = await getArtifactFromOptions(name, options);
        const { artifact } = artifactInfo;
        const abi = artifact.abi;
        const byteCode = linkLibraries(artifact, options.libraries);
        const factory = new contracts_1.ContractFactory(abi, byteCode, ethersSigner);
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice,
            value: options.value,
            nonce: options.nonce
        };
        const unsignedTx = factory.getDeployTransaction(...args, overrides);
        if (typeof unsignedTx.data !== "string") {
            throw new Error("unsigned tx data as bytes not supported");
        }
        else {
            return {
                address: getCreate2Address("0x4e59b44847b379578588920ca78fbf26c0b4956c", options.salt
                    ? bytes_1.hexlify(bytes_1.zeroPad(options.salt, 32))
                    : "0x0000000000000000000000000000000000000000000000000000000000000000", unsignedTx.data),
                deploy: () => deploy(name, Object.assign(Object.assign({}, options), { useCreate2: options.salt || true }))
            };
        }
    }
    function getDeployment(name) {
        return env.deployments.get(name);
    }
    function getDeploymentOrNUll(name) {
        return env.deployments.getOrNull(name);
    }
    async function fetchIfDifferent(name, options) {
        const argArray = options.args ? [...options.args] : [];
        await init();
        if (options.useCreate2) {
            // TODO remove duplication:
            const { address: from, ethersSigner } = getFrom(options.from);
            if (!ethersSigner) {
                throw new Error("no signer for " + from);
            }
            const artifactInfo = await getArtifactFromOptions(name, options);
            const { artifact } = artifactInfo;
            const { contractName } = artifactInfo;
            const abi = artifact.abi;
            const byteCode = linkLibraries(artifact, options.libraries);
            const factory = new contracts_1.ContractFactory(abi, byteCode, ethersSigner);
            const overrides = {
                gasLimit: options.gasLimit,
                gasPrice: options.gasPrice,
                value: options.value,
                nonce: options.nonce
            };
            const unsignedTx = factory.getDeployTransaction(...argArray, overrides);
            if (typeof unsignedTx.data === "string") {
                const create2Salt = typeof options.useCreate2 === "string"
                    ? bytes_1.hexlify(bytes_1.zeroPad(options.useCreate2, 32))
                    : "0x0000000000000000000000000000000000000000000000000000000000000000";
                const create2DeployerAddress = "0x4e59b44847b379578588920ca78fbf26c0b4956c";
                const create2Address = getCreate2Address(create2DeployerAddress, create2Salt, unsignedTx.data);
                const code = await provider.getCode(create2Address);
                return code === "0x";
            }
            else {
                throw new Error("unsigned tx data as bytes not supported");
            }
        }
        const fieldsToCompareArray = typeof options.fieldsToCompare === "string"
            ? [options.fieldsToCompare]
            : options.fieldsToCompare || [];
        const deployment = await env.deployments.getOrNull(name);
        if (deployment) {
            if (options.skipIfAlreadyDeployed) {
                return false; // TODO check receipt, see below
            }
            // TODO transactionReceipt + check for status
            const transaction = await provider.getTransaction(deployment.receipt.transactionHash);
            if (transaction) {
                const { artifact } = await getArtifactFromOptions(name, options);
                const abi = artifact.abi;
                const byteCode = linkLibraries(artifact, options.libraries);
                const factory = new contracts_1.ContractFactory(abi, byteCode, provider.getSigner(options.from));
                const compareOnData = fieldsToCompareArray.indexOf("data") !== -1;
                let data;
                if (compareOnData) {
                    const deployStruct = factory.getDeployTransaction(...argArray);
                    data = deployStruct.data;
                }
                const newTransaction = {
                    data: compareOnData ? data : undefined,
                    gasLimit: options.gasLimit,
                    gasPrice: options.gasPrice,
                    value: options.value,
                    from: options.from
                };
                transaction.data = transaction.data;
                for (const field of fieldsToCompareArray) {
                    if (typeof newTransaction[field] === "undefined") {
                        throw new Error("field " +
                            field +
                            " not specified in new transaction, cant compare");
                    }
                    if (transaction[field] !== newTransaction[field]) {
                        return true;
                    }
                }
                return false;
            }
        }
        return true;
    }
    async function _deployOne(name, options) {
        const argsArray = options.args ? [...options.args] : [];
        options = Object.assign(Object.assign({}, options), { args: argsArray });
        if (options.fieldsToCompare === undefined) {
            options.fieldsToCompare = ["data"];
        }
        let result;
        if (options.fieldsToCompare) {
            const differences = await fetchIfDifferent(name, options);
            if (differences) {
                result = await _deploy(name, options);
            }
            else {
                result = (await getDeployment(name));
            }
        }
        else {
            result = await _deploy(name, options);
        }
        if (options.log) {
            if (result.newlyDeployed) {
                log(`"${name}" deployed at ${result.address} with ${result.receipt.gasUsed} gas`);
            }
            else {
                log(`reusing "${name}" at ${result.address}`);
            }
        }
        return result;
    }
    function _checkUpgradeIndex(oldDeployment, upgradeIndex) {
        if (typeof upgradeIndex === "undefined") {
            return;
        }
        if (upgradeIndex === 0) {
            if (oldDeployment) {
                return Object.assign(Object.assign({}, oldDeployment), { newlyDeployed: false });
            }
        }
        else if (upgradeIndex === 1) {
            if (!oldDeployment) {
                throw new Error("upgradeIndex === 1 : expects Deployments to already exists");
            }
            if (oldDeployment.history && oldDeployment.history.length > 0) {
                return Object.assign(Object.assign({}, oldDeployment), { newlyDeployed: false });
            }
        }
        else {
            if (!oldDeployment) {
                throw new Error(`upgradeIndex === ${upgradeIndex} : expects Deployments to already exists`);
            }
            if (!oldDeployment.history) {
                throw new Error(`upgradeIndex > 1 : expects Deployments history to exists`);
            }
            else if (oldDeployment.history.length > upgradeIndex - 1) {
                return Object.assign(Object.assign({}, oldDeployment), { newlyDeployed: false });
            }
            else if (oldDeployment.history.length < upgradeIndex - 1) {
                throw new Error(`upgradeIndex === ${upgradeIndex} : expects Deployments history length to be at least ${upgradeIndex -
                    1}`);
            }
        }
    }
    async function _deployViaTransparentProxy(name, options) {
        const oldDeployment = await getDeploymentOrNUll(name);
        let updateMethod;
        let upgradeIndex;
        if (typeof options.proxy === "object") {
            upgradeIndex = options.proxy.upgradeIndex;
            updateMethod = options.proxy.methodName;
        }
        else if (typeof options.proxy === "string") {
            updateMethod = options.proxy;
        }
        const deployResult = _checkUpgradeIndex(oldDeployment, upgradeIndex);
        if (deployResult) {
            return deployResult;
        }
        const implementationName = name + "_Implementation";
        const proxyName = name + "_Proxy";
        const argsArray = options.args ? [...options.args] : [];
        const implementationOptions = Object.assign({}, options);
        delete implementationOptions.proxy;
        if (!implementationOptions.contract) {
            implementationOptions.contract = name;
        }
        const { address: owner } = getProxyOwner(options);
        const { artifact } = await getArtifactFromOptions(implementationName, implementationOptions);
        const constructor = artifact.abi.find((fragment) => fragment.type === "constructor");
        if (!constructor || constructor.inputs.length !== argsArray.length) {
            delete implementationOptions.args;
            if (constructor && constructor.inputs.length > 0) {
                throw new Error(`Proxy based contract constructor can only have either zero argument or the exact same argument as the method used for postUpgrade actions ${updateMethod ? "(" + updateMethod + "}" : ""}.
Plus they are only used when the contract is meant to be used as standalone when development ends.
`);
            }
        }
        const implementation = await _deployOne(implementationName, implementationOptions);
        if (implementation.newlyDeployed) {
            // console.log(`implementation deployed at ${implementation.address} for ${implementation.receipt.gasUsed}`);
            const implementationContract = new contracts_1.Contract(implementation.address, implementation.abi);
            let data = "0x";
            if (updateMethod) {
                if (!implementationContract[updateMethod]) {
                    throw new Error(`contract need to implement function ${updateMethod}`);
                }
                const txData = await implementationContract.populateTransaction[updateMethod](...argsArray);
                data = txData.data || "0x";
            }
            let proxy = await getDeploymentOrNUll(proxyName);
            if (!proxy) {
                const proxyOptions = Object.assign({}, options);
                delete proxyOptions.proxy;
                proxyOptions.contract = TransparentProxy_json_1.default;
                proxyOptions.args = [implementation.address, data, owner];
                proxy = await _deployOne(proxyName, proxyOptions);
                // console.log(`proxy deployed at ${proxy.address} for ${proxy.receipt.gasUsed}`);
            }
            else {
                const currentOwner = await read(proxyName, "proxyAdmin");
                // let currentOwner;
                // try {
                //   currentOwner = await provider.getStorageAt(
                //     proxy.address,
                //     "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6102"
                //   );
                //   console.log({ currentOwner });
                // } catch (e) {
                //   console.error(e);
                // }
                if (currentOwner.toLowerCase() !== owner.toLowerCase()) {
                    throw new Error("To change owner, you need to call `transferOwnership`");
                }
                const executeReceipt = await execute(proxyName, Object.assign({}, options), "changeImplementation", implementation.address, data);
                if (!executeReceipt) {
                    throw new Error("could not execute `changeImplementation`");
                }
            }
            const proxiedDeployment = Object.assign(Object.assign({}, implementation), { address: proxy.address, execute: updateMethod
                    ? {
                        methodName: updateMethod,
                        args: argsArray
                    }
                    : undefined });
            if (oldDeployment) {
                proxiedDeployment.history = proxiedDeployment.history
                    ? proxiedDeployment.history.concat([oldDeployment])
                    : [oldDeployment];
            }
            await env.deployments.save(name, proxiedDeployment);
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: true });
        }
        else {
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: false });
        }
    }
    function getProxyOwner(options) {
        let address = options.from; // admim default to msg.sender
        if (typeof options.proxy === "object") {
            address = options.proxy.owner || address;
        }
        return getFrom(address);
    }
    function getOptionalFrom(from) {
        return _getFrom(from, true);
    }
    function getFrom(from) {
        return _getFrom(from, false);
    }
    function _getFrom(from, optional) {
        let ethersSigner;
        if (!from) {
            if (optional) {
                return {};
            }
            throw new Error("no from specified");
        }
        if (from.length >= 64) {
            if (from.length === 64) {
                from = "0x" + from;
            }
            const wallet = new wallet_1.Wallet(from);
            from = wallet.address;
            ethersSigner = wallet;
        }
        else {
            if (availableAccounts[from.toLowerCase()]) {
                ethersSigner = provider.getSigner(from);
            }
        }
        return { address: from, ethersSigner };
    }
    async function findEvents(contract, event, blockHash) {
        // TODO type the return type
        const filter = contract.filters[event]();
        const events = await contract.queryFilter(filter, blockHash);
        return events;
    }
    function extractFacetInfo(facetBytes) {
        const address = facetBytes.slice(0, 42);
        const rest = facetBytes.slice(42);
        const sigs = [];
        for (let i = 0; i < rest.length; i += 8) {
            sigs.push("0x" + rest.slice(i, i + 8));
        }
        return {
            address,
            sigs
        };
    }
    function sigsFromABI(abi) {
        return abi
            .filter((fragment) => fragment.type === "function")
            .map((fragment) => abi_1.Interface.getSighash(abi_1.FunctionFragment.from(fragment)));
    }
    async function _deployViaDiamondProxy(name, options) {
        const oldDeployment = await getDeploymentOrNUll(name);
        let proxy;
        const deployResult = _checkUpgradeIndex(oldDeployment, options.upgradeIndex);
        if (deployResult) {
            return deployResult;
        }
        const proxyName = name + "_DiamondProxy";
        const { address: owner, ethersSigner: ownerSigner } = getProxyOwner(options);
        const diamantaireName = name + "_Diamantaire";
        const facetSnapshot = [];
        const oldFacets = [];
        if (oldDeployment) {
            proxy = await getDeployment(proxyName);
            const diamondProxy = new contracts_1.Contract(proxy.address, proxy.abi, provider);
            const facetsBytes = await diamondProxy.facets();
            for (const facetBytes of facetsBytes) {
                oldFacets.push(extractFacetInfo(facetBytes));
                // ensure EIP165, LoupeFacet, DiamondOwnershipFacet and DiamondFacet are kept // TODO options to delete cut them out?
                const sigsBytes = facetBytes.slice(42);
                if (sigsBytes === "01ffc9a7" || // ERC165
                    sigsBytes === "adfca15e7a0ed627cdffacc652ef6b2c" || // Loupe
                    sigsBytes === "99f5f52e" || // DiamoncCut
                    sigsBytes === "f2fde38b8da5cb5b" // ERC173
                ) {
                    facetSnapshot.push(extractFacetInfo(facetBytes));
                }
            }
        }
        // console.log({ oldFacets: JSON.stringify(oldFacets, null, "  ") });
        let changesDetected = !oldDeployment;
        let abi = [];
        const facetCuts = [];
        for (const facet of options.facets) {
            const artifact = await getArtifact(facet); // TODO getArtifactFromOptions( // allowing to pass bytecode / abi
            const constructor = artifact.abi.find((fragment) => fragment.type === "constructor");
            if (constructor) {
                throw new Error(`Facet must not have a constructor`);
            }
            abi = mergeAndCheckDiamondAbis(abi, artifact.abi);
            // TODO allow facet to be named so multiple version could coexist
            const implementation = await _deployOne(facet, {
                from: options.from,
                log: options.log,
                libraries: options.libraries
            });
            if (implementation.newlyDeployed) {
                // console.log(`facet ${facet} deployed at ${implementation.address}`);
                changesDetected = true;
                const facetCut = {
                    address: implementation.address,
                    sigs: sigsFromABI(implementation.abi)
                };
                facetCuts.push(facetCut);
                facetSnapshot.push(facetCut);
            }
            else {
                const oldImpl = await getDeployment(facet);
                const facetCut = {
                    address: oldImpl.address,
                    sigs: sigsFromABI(oldImpl.abi)
                };
                facetSnapshot.push(facetCut);
                if (!oldFacets.find(f => f.address.toLowerCase() === oldImpl.address.toLowerCase())) {
                    facetCuts.push(facetCut);
                }
            }
        }
        for (const oldFacet of oldFacets) {
            if (!facetSnapshot.find(f => f.address.toLowerCase() === oldFacet.address.toLowerCase())) {
                changesDetected = true;
                facetCuts.unshift({
                    address: "0x0000000000000000000000000000000000000000",
                    sigs: oldFacet.sigs
                });
            }
        }
        let data = "0x";
        if (options.execute) {
            const diamondContract = new contracts_1.Contract("0x0000000000000000000000000000000000000001", abi);
            const txData = await diamondContract.populateTransaction[options.execute.methodName](...options.execute.args);
            data = txData.data || "0x";
        }
        if (changesDetected) {
            const cuts = facetCuts.map(facetCut => {
                return facetCut.sigs.reduce((prev, curr) => (prev += curr.slice(2)), facetCut.address);
            });
            let diamantaireDeployment = await getDeploymentOrNUll(diamantaireName);
            if (!proxy || !diamantaireDeployment) {
                if (proxy || diamantaireDeployment) {
                    throw new Error("proxy and Diamantaire should go together, something is wrong with your saved deployments");
                }
                diamantaireDeployment = await _deployOne(diamantaireName, {
                    from: options.from,
                    contract: Diamantaire_json_1.default,
                    args: [owner, cuts, data],
                    log: false
                });
                const receipt = diamantaireDeployment.receipt;
                // console.log(JSON.stringify(receipt, null, "  "));
                // const diamondCreatedEvent =
                //   receipt.events &&
                //   receipt.events.find(event => event.event === "DiamondCreated");
                const diamantaireContract = new contracts_1.Contract(diamantaireDeployment.address, Diamantaire_json_1.default.abi, provider);
                const events = [];
                if (receipt.logs) {
                    for (const l of receipt.logs) {
                        try {
                            events.push(diamantaireContract.interface.parseLog(l));
                        }
                        catch (e) { }
                    }
                }
                const diamondCreatedEvent = events.find(e => e.name === "DiamondCreated");
                if (!diamondCreatedEvent) {
                    throw new Error("DiamondCreated Not Emitted");
                }
                const proxyAddress = diamondCreatedEvent.args.diamond;
                if (options.log) {
                    log(`Diamond deployed at ${proxyAddress} via Diamantaire (${diamantaireDeployment.address}) cuts: ${cuts} with ${receipt.gasUsed} gas`);
                }
                proxy = {
                    abi: DiamondBase_json_1.default.abi,
                    address: proxyAddress,
                    receipt,
                    args: [diamantaireDeployment.address],
                    bytecode: DiamondBase_json_1.default.bytecode,
                    deployedBytecode: DiamondBase_json_1.default.deployedBytecode,
                    metadata: DiamondBase_json_1.default.metadata
                    // TODO if more fiels are added, we need to add more
                };
                await env.deployments.save(proxyName, proxy);
                await env.deployments.save(name, {
                    address: proxy.address,
                    receipt: proxy.receipt,
                    linkedData: options.linkedData,
                    facets: facetSnapshot,
                    diamondCuts: cuts,
                    abi,
                    execute: options.execute
                    // metadata: diamondBase.metadata
                });
            }
            else {
                if (!oldDeployment) {
                    throw new Error(`Cannot find Deployment for ${name}`);
                }
                const currentOwner = await read(proxyName, "owner");
                if (currentOwner.toLowerCase() !==
                    diamantaireDeployment.address.toLowerCase()) {
                    throw new Error(`The Diamond owner is not the Diamantaire Contract anymore. Cannot proceed.`);
                }
                const executeReceipt = await execute(diamantaireName, options, "cutAndExecute", cuts, data);
                if (!executeReceipt) {
                    throw new Error("failed to execute");
                }
                await env.deployments.save(name, {
                    receipt: executeReceipt,
                    history: oldDeployment.history
                        ? oldDeployment.history.concat(oldDeployment)
                        : [oldDeployment],
                    linkedData: options.linkedData,
                    address: proxy.address,
                    abi,
                    facets: facetSnapshot,
                    diamondCuts: cuts,
                    execute: options.execute
                    // metadata: oldDeployment.metadata
                });
            }
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: true });
        }
        else {
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: false });
        }
    }
    async function diamondAsOwner(name, options, methodName, ...args) {
        await init();
        const deployment = await getDeployment(name);
        const diamantaireName = name + "_Diamantaire";
        const diamondContract = new contracts_1.Contract(deployment.address, deployment.abi);
        const txData = await diamondContract.populateTransaction[methodName](...args);
        const data = txData.data || "0x";
        return execute(diamantaireName, options, "execute", data);
    }
    async function deploy(name, options) {
        await init();
        if (!options.proxy) {
            return _deployOne(name, options);
        }
        return _deployViaTransparentProxy(name, options);
    }
    async function diamond(name, options) {
        await init();
        return _deployViaDiamondProxy(name, options);
    }
    async function batchExecute(txs, batchOptions) {
        await init();
        const promises = [];
        const currentNonces = {};
        const savedTxs = [];
        for (const tx of txs) {
            const newTx = Object.assign({}, tx);
            if (tx.args) {
                newTx.args = [...tx.args];
            }
            else {
                newTx.args = [];
            }
            savedTxs.push();
        }
        for (const tx of savedTxs) {
            const { address: from, ethersSigner } = getFrom(tx.from);
            const nonce = tx.nonce ||
                currentNonces[from] ||
                (await provider.getTransactionCount(from));
            tx.nonce = nonce;
            currentNonces[from] = nonce + 1;
            const args = tx.args || [];
            promises.push(execute(tx.name, tx, tx.methodName, ...args));
        }
        if (batchOptions.dev_forceMine) {
            try {
                await provider.send("evm_mine", []);
            }
            catch (e) { }
        }
        return Promise.all(promises);
    }
    async function rawTx(tx) {
        await init();
        const { address: from, ethersSigner } = getFrom(tx.from);
        if (!ethersSigner) {
            console.error("no signer for " + from);
            console.log(`Please execute the following as ${from}`);
            console.log(`
to: ${tx.to}
data: ${tx.data}
`);
            if (tx.skipUnknownSigner) {
                return null;
            }
            throw new Error("ABORT, ACTION REQUIRED, see above");
        }
        else {
            const transactionData = {
                to: tx.to,
                gasLimit: tx.gasLimit,
                gasPrice: tx.gasPrice ? bignumber_1.BigNumber.from(tx.gasPrice) : undefined,
                value: tx.value ? bignumber_1.BigNumber.from(tx.value) : undefined,
                nonce: tx.nonce,
                data: tx.data
            };
            let pendingTx = await ethersSigner.sendTransaction(transactionData);
            pendingTx = await onPendingTx(pendingTx);
            if (tx.dev_forceMine) {
                try {
                    await provider.send("evm_mine", []);
                }
                catch (e) { }
            }
            return pendingTx.wait();
        }
    }
    async function execute(name, options, methodName, ...args) {
        await init();
        const { address: from, ethersSigner } = getFrom(options.from);
        let tx;
        const deployment = await env.deployments.get(name);
        const abi = deployment.abi;
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice ? bignumber_1.BigNumber.from(options.gasPrice) : undefined,
            value: options.value ? bignumber_1.BigNumber.from(options.value) : undefined,
            nonce: options.nonce
        };
        const ethersContract = new contracts_1.Contract(deployment.address, abi, ethersSigner || provider);
        if (!ethersContract.functions[methodName]) {
            throw new Error(`No method named "${methodName}" on contract deployed as "${name}"`);
        }
        if (!ethersSigner) {
            // ethers.js : would be nice to be able to estimate even if not access to signer (see below)
            console.error("no signer for " + from);
            console.log(`Please execute the following on ${name} as ${from}`);
            const ethersArgs = args ? args.concat([overrides]) : [overrides];
            const { data } = await ethersContract.populateTransaction[methodName](...ethersArgs);
            console.log(`
to: ${deployment.address}
data: ${data}
`);
            console.log("if you have an interface use the following");
            console.log(`
to: ${deployment.address} (${name})
method: ${methodName}
args: [${args.join(" , ")}]
`);
            if (options.skipUnknownSigner) {
                return null;
            }
            throw new Error("ABORT, ACTION REQUIRED, see above");
        }
        else {
            await overrideGasLimit(overrides, options, newOverrides => {
                const ethersArgsWithGasLimit = args
                    ? args.concat([newOverrides])
                    : [newOverrides];
                return ethersContract.estimateGas[methodName](...ethersArgsWithGasLimit);
            });
            await setupGasPrice(overrides);
            const ethersArgs = args ? args.concat([overrides]) : [overrides];
            tx = await ethersContract.functions[methodName](...ethersArgs);
        }
        tx = await onPendingTx(tx);
        if (options.log) {
            print(`executing ${name}.${methodName}... `);
        }
        if (options.dev_forceMine) {
            try {
                await provider.send("evm_mine", []);
            }
            catch (e) { }
        }
        const receipt = await tx.wait();
        if (options.log) {
            print(`: performed with ${receipt.gasUsed} gas\n`);
        }
        return receipt;
    }
    // TODO ?
    // async function rawCall(to: string, data: string) {
    //   // TODO call it eth_call?
    //   await init();
    //   return provider.send("eth_call", [
    //     {
    //       to,
    //       data
    //     },
    //     "latest"
    //   ]); // TODO overrides
    // }
    async function read(name, options, methodName, ...args) {
        await init();
        if (typeof options === "string") {
            if (typeof methodName !== "undefined") {
                args.unshift(methodName);
            }
            methodName = options;
            options = {};
        }
        if (typeof args === "undefined") {
            args = [];
        }
        let caller = provider;
        const { ethersSigner } = getOptionalFrom(options.from);
        if (ethersSigner) {
            caller = ethersSigner;
        }
        const deployment = await env.deployments.get(name);
        if (!deployment) {
            throw new Error(`no contract named "${name}"`);
        }
        const abi = deployment.abi;
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice ? bignumber_1.BigNumber.from(options.gasPrice) : undefined,
            value: options.value ? bignumber_1.BigNumber.from(options.value) : undefined,
            nonce: options.nonce
        };
        const ethersContract = new contracts_1.Contract(deployment.address, abi, caller);
        // populate function
        // if (options.outputTx) {
        //   const method = ethersContract.populateTransaction[methodName];
        //   if (!method) {
        //     throw new Error(
        //       `no method named "${methodName}" on contract "${name}"`
        //     );
        //   }
        //   if (args.length > 0) {
        //     return method(...args, overrides);
        //   } else {
        //     return method(overrides);
        //   }
        // }
        const method = ethersContract.callStatic[methodName];
        if (!method) {
            throw new Error(`no method named "${methodName}" on contract "${name}"`);
        }
        if (args.length > 0) {
            return method(...args, overrides);
        }
        else {
            return method(overrides);
        }
    }
    const extension = Object.assign(Object.assign({}, partialExtension), { fetchIfDifferent,
        deploy, diamond: {
            deploy: diamond,
            executeAsOwner: diamondAsOwner
        }, execute,
        batchExecute,
        rawTx,
        read,
        create2 });
    // ////////// Backward compatible for transition: //////////////////
    extension.call = (options, name, methodName, ...args) => {
        if (typeof options === "string") {
            args = args || [];
            if (methodName !== undefined) {
                args.unshift(methodName);
            }
            methodName = name;
            name = options;
            options = {};
        }
        return read(name, options, methodName, ...args);
    };
    extension.sendTxAndWait = (options, name, methodName, ...args) => {
        return execute(name, options, methodName, ...args);
    };
    extension.deployIfDifferent = (fieldsToCompare, name, options, contractName, ...args) => {
        options.fieldsToCompare = fieldsToCompare;
        options.contract = contractName;
        options.args = args;
        return deploy(name, options);
    };
    // ////////////////////////////////////////////////////////////////////
    return extension;
}
exports.addHelpers = addHelpers;
function pause(duration) {
    return new Promise(res => setTimeout(res, duration * 1000));
}
async function waitForTx(ethereum, txHash, isContract) {
    let receipt;
    while (true) {
        try {
            receipt = await ethereum.send("eth_getTransactionReceipt", [txHash]);
        }
        catch (e) { }
        if (receipt && receipt.blockNumber) {
            if (isContract) {
                if (!receipt.contractAddress) {
                    throw new Error("contract not deployed");
                }
                else {
                    return receipt;
                }
            }
            else {
                return receipt;
            }
        }
        await pause(2);
    }
}
exports.waitForTx = waitForTx;
//# sourceMappingURL=helpers.js.map